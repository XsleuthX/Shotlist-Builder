<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Shot List Builder</title>
<style>

/* =============================
   Impression — Gold Glass Theme
   (CSS-only; HTML/JS untouched)
   ============================= */
:root{
  --gutter: clamp(18px, 4vw, 48px);
  --bg-0:#0a0e14; --bg-1:#0d121a; --bg-2:#111726;
  --ink:#eef2f7; --ink-dim:#b8c2d6;
  --line:#2a354a; --line-soft:rgba(255,255,255,.06);
  --accent:#e9d6a6;             /* warm gold */
  --accent-strong:#ffd87a;      /* bright gold highlight */
  --ok:#c2c522; --danger:#446cef;
  --shadow-1: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  --r-xl:18px; --r-lg:14px; --r-md:10px; --r-sm:8px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--ink);
  font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  background:
    radial-gradient(1200px 600px at 20% -10%, #1b2436 0%, transparent 60%),
    radial-gradient(1000px 500px at 120% 20%, #132034 0%, transparent 60%),
    linear-gradient(180deg, #080b10, #0a0e14 40%, #0a0e14);
}
/* Scrollbar */
*::-webkit-scrollbar{height:12px;width:12px}
*::-webkit-scrollbar-thumb{background:#1d2636;border:3px solid transparent;border-radius:12px;background-clip:padding-box}
*{scrollbar-color:#1d2636 transparent; scrollbar-width:thin}

/* Header */
header{position:sticky; top:0; z-index:5; backdrop-filter:saturate(140%) blur(8px);
  background:linear-gradient(180deg, rgba(11,15,21,.85), rgba(11,15,21,.65) 70%, rgba(11,15,21,0));
  border-bottom:1px solid var(--line)}
.wrap{max-width:1200px; margin:0 auto; padding:12px var(--gutter)}
h1{margin:0 0 6px; font-size:18px; letter-spacing:.2px}
.sub{color:var(--ink-dim); margin-bottom:10px}

/* Toolbar */
.bar{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
.group{
  display:flex; gap:10px; padding:8px;
  background:rgba(255,255,255,.02);
  border:1px solid var(--line);
  border-radius:var(--r-xl);
  box-shadow:var(--shadow-1);
  backdrop-filter: blur(6px) saturate(120%);
}
.group .label{font-size:12px; color:var(--ink-dim); align-self:center; margin-right:2px; letter-spacing:.2px}

/* Buttons: transparent glass + gold dot */
button,.btn{
  position:relative;
  background:rgba(255,255,255,.04);
  color:var(--ink);
  border:1px solid var(--line);
  padding:10px 14px 10px 32px; border-radius:999px; cursor:pointer;
  box-shadow:var(--shadow-1);
  transition: border-color .15s ease, box-shadow .15s ease, background .15s ease, transform .05s ease;
}
button:hover,.btn:hover{border-color:rgba(255,255,255,.18); background:rgba(255,255,255,.055)}
button:active,.btn:active{transform:translateY(1px)}
button[disabled],.btn[disabled]{opacity:.55; cursor:not-allowed}
/* left gold dot */
button::before,.btn::before{
  content:"";
  position:absolute; left:12px; top:50%; transform:translateY(-50%);
  width:8px; height:8px; border-radius:50%;
  background: radial-gradient(circle at 35% 35%, #fff6d6 0, var(--accent) 50%, #826a2e 100%);
  box-shadow:0 0 0 2px rgba(233,214,166,.18), 0 0 12px rgba(233,214,166,.35);
}
/* Variants */
.btn.ok{border-color:#555b1e; background:(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:rgba(255,222,132,.8); box-shadow:0 6px 18px rgba(255,222,132,.24), font}
.btn.ok::before{
  background:linear-gradient(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:#0b1018; box-shadow:0 6px 18px rgba(255,222,132,.24), inset 0 1px 0 rgba(255,255,255,.25);
                   border-color:rgba(255,222,132,.35)}

.btn.danger{border-color:#8cdbff; background:rgba(#1b637f,.14); color:#d9feff}
.btn.danger::before{background: radial-gradient(circle at 35% 35%, #d9feff 0, #8cdbff 55%, #1b637f 100%); box-shadow:0 0 0 2px rgba(140, 251, 255, 0.18), 0 0 12px rgba(255,140,140,.32)}
.btn.muted{background:rgba(255,255,255,.03)}

/* file input label */
input[type=file]{display:none}
label.filebtn{display:inline-flex; align-items:center; gap:8px}

/* Segmented control */
.seg{display:inline-flex; border:1px solid var(--line); border-radius:999px; overflow:hidden; background:rgba(255,255,255,.03)}
.seg button{border:0; background:transparent; padding:8px 12px; border-right:1px solid var(--line); border-radius:0}
.seg button:last-child{border-right:0}
.seg button.active{background:linear-gradient(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:#0b1018; box-shadow:0 6px 18px rgba(255,222,132,.24), inset 0 1px 0 rgba(255,255,255,.25);
                   border-color:rgba(255,222,132,.35)}
/* Remove dots in segmented buttons */
.seg button::before{display:none}
.webp-controls button::before{display:none}

/* Dropzone */
.dropzone{border:1px dashed var(--line); border-radius:var(--r-xl); padding:24px; text-align:center;
  color:var(--ink-dim); background:rgba(255,255,255,.03); box-shadow:var(--shadow-1); backdrop-filter: blur(4px) saturate(110%)}
.dropzone.hover{border-color:var(--accent-strong); color:var(--ink)}

/* List Mode */
table{width:100%; border-collapse:separate; border-spacing:0 12px}
thead th{text-align:left; font-weight:600; color:var(--ink-dim); padding:0 8px 6px; font-size:12px; letter-spacing:.2px}
tbody tr{background:rgba(255,255,255,.04); border:1px solid var(--line); border-radius:var(--r-xl); box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
tbody tr.dragging{opacity:.65; outline:1px dashed var(--accent-strong)}
td{padding:10px; vertical-align:top}
td.idx{width:56px; text-align:right; color:var(--ink-dim)}
td.drag{width:34px; cursor:grab}
.handle{width:10px; height:24px; background:repeating-linear-gradient(90deg,#9097a6 0 2px,transparent 2px 5px); opacity:.35; border-radius:3px; margin-top:3px}
img.thumb{width:160px; height:90px; object-fit:cover; border-radius:12px; display:block; background:#000; box-shadow:0 6px 16px rgba(0,0,0,.35)}
textarea,input[type=text],input[type=number],select{
  width:100%; background:rgba(255,255,255,.03);
  color:var(--ink); border:1px solid var(--line); border-radius:12px; padding:10px;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.03);
}
textarea{min-height:68px; resize:vertical}
.grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
.mini{font-size:12px; color:var(--ink-dim)}
.tags{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.chip{border:1px solid var(--line); background:rgba(255,255,255,.03); padding:4px 10px; border-radius:999px; font-size:12px; color:#cbd6ea}
.sel{width:36px; text-align:center}
.sel input{transform:scale(1.1); accent-color: var(--accent-strong)}

.topbar{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.spacer{flex:1}

/* Batch panel */
.panel{background:rgba(255,255,255,.035); border:1px solid var(--line); border-radius:var(--r-xl); padding:0; overflow:hidden; box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
.panel .panel-summary{display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; user-select:none}
.panel .panel-summary .title{font-weight:700; letter-spacing:.2px}
details.panel>.panel-summary::marker{content:""}
details.panel>.panel-summary::after{content:"▾"; margin-left:8px; color:var(--ink-dim)}
details.panel[open]>.panel-summary::after{content:"▴"}
.panel .panel-content{padding:12px}

/* Page Mode */
#pageContainer{margin-top:12px}
.page-grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(320px,1fr)); gap:12px}
.card{background:rgba(255,255,255,.04); border:1px solid var(--line); border-radius:var(--r-xl); padding:12px; box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
.card.dragging{opacity:.65; outline:1px dashed var(--accent-strong)}
.card .head{display:flex; align-items:center; gap:10px; margin-bottom:8px}
.star{cursor:pointer; font-size:18px; line-height:1; user-select:none; color:#c0a96f}
.star.on{color:#ffd166; text-shadow:0 0 12px rgba(255,209,102,.35)}
.idxbadge{font:600 12px/1 ui-sans-serif,system-ui; color:#e6e2d1; padding:6px 8px; border-radius:10px; background:rgba(255,255,255,.03); border:1px solid var(--line)}
.title-input{flex:1; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid var(--line); color:var(--ink)}
.media{position:relative; margin-bottom:10px}
.media img,.media video{width:100%; height:200px; object-fit:cover; border-radius:14px; display:block; background:#000; box-shadow:0 10px 30px rgba(0,0,0,.35)}
.replace{position:absolute; top:10px; right:10px}
.grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
.bar-l2{display:flex; gap:8px; align-items:center; margin-top:6px}
.format-chip{font-size:11px}
.drag-handle{width:12px; height:24px; background:repeating-linear-gradient(90deg,#9097a6 0 2px,transparent 2px 5px); opacity:.35; border-radius:3px; cursor:grab}
.toggleFields{border-radius:12px; padding:6px 10px}
.fields-collapsed .fields{display:none}
.fields-collapsed .toggleFields::after{content:"▸"}
.toggleFields::after{content:"▾"}

/* Footer */
footer{position:fixed; bottom:0; left:0; right:0; background:linear-gradient(0deg, rgba(11,15,21,.96), rgba(11,15,21,.75), rgba(11,15,21,0)); border-top:1px solid var(--line)}
.footwrap{max-width:1200px; margin:0 auto; padding:12px var(--gutter); display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace; background:rgba(255,255,255,.03); border:1px solid var(--line); padding:2px 8px; border-radius:8px; font-size:12px; color:#e6e2d1; box-shadow:var(--shadow-1)}
.hidden{display:none!important}

</style>
<style>
/* ===== Gutter Guard (conflict-proof) ===== */
:root{ --gutter: clamp(18px, 4vw, 48px); }
header > .wrap,
footer > .footwrap{
  max-width: 1320px;
  margin-left: auto; margin-right: auto;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}
main{
  max-width: 1320px;
  margin: 14px auto;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}
@media (min-width: 1600px){
  header > .wrap, footer > .footwrap, main{ max-width: 1400px; }
}
</style>

<style>
/* Bottom gutter + footer-safe space */
:root{ --gutter: clamp(18px, 4vw, 48px); }
main{
  padding-bottom: max(var(--gutter), 120px) !important; /* leave room for fixed footer and match side gutters */
}
</style>


<style>
/* === Invisible Scrollbars (keep scroll behavior) === */
html, body{
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  -ms-overflow-style: none;           /* IE 10+ & old Edge */
  scrollbar-width: none;              /* Firefox */
  -webkit-overflow-scrolling: touch;  /* iOS momentum */
}
html::-webkit-scrollbar,
body::-webkit-scrollbar{
  width: 0 !important;
  height: 0 !important;
}

/* Optional: hide scrollbars on all inner scroll containers, while preserving scroll */
*{
  -ms-overflow-style: none;
  scrollbar-width: none;
}
*::-webkit-scrollbar{
  width: 0 !important;
  height: 0 !important;
}

/* === Replace button only on hover of media === */
.media .replace{
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity .18s ease, transform .18s ease, filter .18s ease;
  filter: blur(.2px);
}
.media:hover .replace,
.media:focus-within .replace,
.replace:focus-visible{
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
  filter: none;
}
@media (hover: none) and (pointer: coarse){
  .media .replace{ opacity:1; pointer-events:auto; transform:none; filter:none; }
}
</style>


<style>
.webp-controls{display:flex;gap:.5rem;align-items:center;margin-top:.5rem;flex-wrap:wrap}
.webp-controls button{padding:6px 10px;border-radius:6px;border:1px solid var(--border,#333);background:var(--btn-bg,#222);color:inherit}
.webp-controls input[type=range]{width:240px}
canvas.webpCanvas{max-width:100%;height:auto;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.15);}
</style>


<script>
// Ensure WebPPlayer exists early (runs before main script)
(function(){
  if ('WebPPlayer' in window) return;
  window._webpPlayers = window._webpPlayers || new Map();
  // Minimal WebP canvas player using WebCodecs
  class WebPPlayer {
    constructor(canvas, url){
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.url = url;
      this.frames = [];
      this.durations = [];
      this.size = null;
      this.index = 0;
      this.playing = false;
      this.t = null;
    }
    async load(){
      if (!('ImageDecoder' in window)) throw new Error('WebCodecs ImageDecoder not supported');
      const res = await fetch(this.url);
      const blob = await res.blob();
      const data = new Uint8Array(await blob.arrayBuffer());
      const decoder = new ImageDecoder({data, type:'image/webp'});
      await decoder.tracks.ready;
      const frameCount = decoder.tracks.selectedTrack?.frameCount ?? decoder.completeFrameCount ?? decoder.frameCount ?? 0;
      const count = Math.max(frameCount || 0, 1);
      this.frames = new Array(count);
      this.durations = new Array(count);
      for (let i=0; i<count; i++){
        const {image} = await decoder.decode({frameIndex:i});
        const bmp = await createImageBitmap(image);
        this.frames[i] = bmp;
        this.durations[i] = (typeof image.duration === 'number' && image.duration>0) ? image.duration : 100;
        this.size = {w: image.displayWidth || bmp.width, h: image.displayHeight || bmp.height};
        image.close();
      }
      decoder.close();
      this.canvas.width = this.size.w;
      this.canvas.height = this.size.h;
      this.draw(0);
    }
    draw(i){
      this.index = i|0;
      if(!this.frames.length) return;
      this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
      const frame = this.frames[this.index % this.frames.length];
      if(frame) this.ctx.drawImage(frame, 0, 0);
    }
    play(onIndex){
      if(this.playing || !this.frames.length) return;
      this.playing = true;
      const tick = () => {
        if(!this.playing) return;
        this.draw(this.index);
        try{ onIndex && onIndex(this.index); }catch{}
        const delay = this.durations[this.index] || 100;
        this.index = (this.index + 1) % this.frames.length;
        this.t = setTimeout(tick, delay);
      };
      tick();
    }
    pause(){
      this.playing = false;
      if(this.t){ clearTimeout(this.t); this.t = null; }
    }
    goto(i, onIndex){
      this.pause();
      this.draw(Math.max(0, Math.min(this.frames.length-1, i|0)));
      try{ onIndex && onIndex(this.index); }catch{}
    }
    seek(i, onIndex){
      this.index = Math.max(0, Math.min(this.frames.length-1, i|0));
      this.draw(this.index);
      try{ onIndex && onIndex(this.index); }catch{}
    }
    dispose(){
      this.pause();
      for(const bmp of this.frames){ try{ bmp.close?.(); }catch{} }
      this.frames = [];
    }
  }
  window.WebPPlayer = WebPPlayer;
})();
</script>

</head>
<body>
<header>
  <div class="wrap">
    <h1>Shot List Builder</h1>
    <div class="sub">Batch drop your shots → reorder → annotate → export as JSON/CSV → print to PDF.</div>

    <div class="bar">
      <div class="group">
        <label class="filebtn btn"><input id="file" type="file" accept="image/*,video/*" multiple> Add Shots</label>
        <button id="clearAll" class="btn danger">Clear All</button>
      </div>

      <div class="group">
        <span class="label">Mode</span>
        <div class="seg">
          <button id="modeList" class="active">List</button>
          <button id="modePage">Page</button>
        </div>
        <label class="mini" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px">
          <input type="checkbox" id="starFilter"> ★ Show starred only
        </label>
        <button id="collapseAllCards" class="btn" disabled title="Collapse all cards in Page Mode">Collapse All</button>
        <button id="expandAllCards" class="btn" disabled title="Expand all cards in Page Mode">Expand All</button>
      </div>

      <div class="group">
        <button id="selectAll" class="btn">Select All</button>
        <button id="deselectAll" class="btn muted">Deselect</button>
        <button id="deleteSel" class="btn danger">Delete Selected</button>
      </div>

      <div class="spacer"></div>

      <div class="group">
        <button id="printBtn" class="btn ok"> Print / Save to PDF</button>
        <button id="exportJSON" class="btn"> Export JSON</button>
        <label class="filebtn btn"><input id="importJSON" type="file" accept="application/json"> Import JSON</label>
        <button id="exportCSV" class="btn"> Export CSV</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div id="dz" class="dropzone">
    <div><strong>Drop your screenshots here</strong> or use <span class="kbd">Add Shots</span>.</div>
    <div class="mini" style="margin-top:6px">Tips: you can drag rows/cards to reorder. Use the print button to generate a print-friendly view and “Save as PDF”.</div>
  </div>

  <!-- Collapsible Batch Tools -->
  <details id="batchPanel" class="panel" open style="margin-top:12px">
    <summary class="panel-summary"><span class="title">Batch Tools</span><span class="spacer"></span><span class="mini">click to show/hide</span></summary>
    <div class="panel-content">
      <div class="topbar">
        <div class="mini">Batch Edit Selected:</div>
        <input type="text" id="batchTitle" placeholder="Shot Title">
        <input type="text" id="batchTake" placeholder="Take">
        <input type="text" id="batchCamera" placeholder="Camera">
        <input type="text" id="batchLens" placeholder="Lens">
        <input type="text" id="batchNotes" placeholder="Notes">
        <input type="text" id="batchDesc" placeholder="Description">
        <button id="applyBatch" class="btn">Apply</button>
        <div class="spacer"></div>
        <div class="mini">Timecode:</div>
        <select id="tcMode" title="Timecode Mode">
          <option value="fromName">Use filename TC</option>
          <option value="timeline">Build timeline from 00:00:00:00</option>
        </select>
        <label class="mini">FPS <input id="fps" type="number" value="24" min="1" max="120" style="width:70px"></label>
        <label class="mini">Default dur (s) <input id="defaultDur" type="number" value="2" min="1" max="3600" style="width:80px"></label>
        <button id="parseTC" class="btn">Parse ↻</button>
      </div>
    </div>
  </details>

  <!-- List Mode -->
  <section id="listSection">
    <table style="margin-top:12px">
      <thead>
        <tr>
          <th class="sel"></th><th class="drag"></th><th class="idx">#</th>
          <th>Thumbnail</th><th>Core</th><th>Details</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </section>

  <!-- Page Mode -->
  <section id="pageSection" class="hidden">
    <div id="pageContainer" class="page-grid"></div>
  </section>
</main>

<footer>
  <div class="footwrap mini">
    <div><strong>Shortcuts:</strong></div>
    <div class="kbd">⌘/Ctrl + A</div><div>select all</div>
    <div class="kbd">Delete</div><div>remove selected</div>
    <div class="kbd">P</div><div>print view</div>
  </div>
</footer>

<template id="row">
  <tr draggable="true">
    <td class="sel"><input type="checkbox" class="selbox"></td>
    <td class="drag"><div class="handle" title="Drag to reorder"></div></td>
    <td class="idx"></td>
    <td>
      <img class="thumb" alt="thumb">
      <div class="mini" data-filename></div>
      <div class="mini"><span class="starlist">☆</span> <span class="kind">IMG</span></div>
    </td>
    <td>
      <div class="grid2">
        <div>
          <label class="mini">Shot Title</label>
          <input type="text" class="title">
        </div>
        <div class="grid2">
          <div>
            <label class="mini">Start TC</label>
            <input type="text" class="starttc" placeholder="HH:MM:SS:FF">
          </div>
          <div>
            <label class="mini">End TC</label>
            <input type="text" class="endtc" placeholder="HH:MM:SS:FF">
          </div>
        </div>
      </div>
      <div style="margin-top:8px">
        <label class="mini">Description</label>
        <textarea class="desc" placeholder="Action, purpose, notes..."></textarea>
      </div>
    </td>
    <td>
      <div class="grid2">
        <div>
          <label class="mini">Camera</label>
          <input type="text" class="camera" placeholder="FX3 / iPhone 15 / ...">
        </div>
        <div>
          <label class="mini">Lens</label>
          <input type="text" class="lens" placeholder="24-70mm @ 50mm">
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label class="mini">Take</label>
          <input type="text" class="take" placeholder="A / B / 2nd">
        </div>
        <div>
          <label class="mini">Notes</label>
          <input type="text" class="notes" placeholder="Any extra notes">
        </div>
      </div>
      <div class="tags" style="margin-top:8px">
        <button class="btn danger mini del">Delete</button>
      </div>
    </td>
  </tr>
</template>

<template id="cardTpl">
  <div class="card fields-collapsed" draggable="true">
    <div class="head">
      <span class="star">☆</span>
      <span class="idxbadge">#001</span>
      <input class="title-input" type="text" placeholder="Shot Title">
      <button class="btn toggleFields" title="Show/Hide fields"></button>
      <div class="drag-handle" title="Drag to reorder"></div>
    </div>
    <div class="media">
      <img class="media-img" alt="thumb">
      <video class="media-vid hidden" controls playsinline></video>
      <button class="btn replace">Replace…</button>
      <input class="replaceInput" type="file" accept="image/*,video/*" style="display:none">
    </div>
    <div class="fields">
      <div class="grid3">
        <div>
          <label class="mini">Start TC</label>
          <input type="text" class="starttc" placeholder="HH:MM:SS:FF">
        </div>
        <div>
          <label class="mini">End TC</label>
          <input type="text" class="endtc" placeholder="HH:MM:SS:FF">
        </div>
        <div>
          <label class="mini">Take</label>
          <input type="text" class="take" placeholder="A / B / 2nd">
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label class="mini">Camera</label>
          <input type="text" class="camera" placeholder="FX3 / iPhone 15 / ...">
        </div>
        <div>
          <label class="mini">Lens</label>
          <input type="text" class="lens" placeholder="24-70mm @ 50mm">
        </div>
      </div>
      <div style="margin-top:8px">
        <label class="mini">Description</label>
        <textarea class="desc" placeholder="Action, purpose, notes..."></textarea>
      </div>
      <div class="bar-l2">
        <span class="chip format-chip kind">IMG</span>
        <span class="mini filename"></span>
        <div class="spacer"></div>
        <button class="btn danger mini del">Delete</button>
      </div>
    </div>
  </div>
</template>

<script>
  const fileInput = document.getElementById('file');
  const dz = document.getElementById('dz');
  const tbody = document.getElementById('tbody');
  const rowTpl = document.getElementById('row');
  const cardTpl = document.getElementById('cardTpl');
  const listSection = document.getElementById('listSection');
  const pageSection = document.getElementById('pageSection');
  const pageContainer = document.getElementById('pageContainer');
  const selectAllBtn = document.getElementById('selectAll');
  const deselectAllBtn = document.getElementById('deselectAll');
  const deleteSelBtn = document.getElementById('deleteSel');
  const clearAllBtn = document.getElementById('clearAll');
  const printBtn = document.getElementById('printBtn');
  const exportJSONBtn = document.getElementById('exportJSON');
  const importJSONInput = document.getElementById('importJSON');
  const exportCSVBtn = document.getElementById('exportCSV');
  const parseTCBtn = document.getElementById('parseTC');
  const applyBatchBtn = document.getElementById('applyBatch');
  const batchTitle = document.getElementById('batchTitle');
  const batchTake = document.getElementById('batchTake');
  const batchCamera = document.getElementById('batchCamera');
  const batchLens = document.getElementById('batchLens');
  const batchNotes = document.getElementById('batchNotes');
  const batchDesc = document.getElementById('batchDesc');
  const tcMode = document.getElementById('tcMode');
  const fpsInput = document.getElementById('fps');
  const defaultDurInput = document.getElementById('defaultDur');
  const modeListBtn = document.getElementById('modeList');
  const modePageBtn = document.getElementById('modePage');
  const starFilter = document.getElementById('starFilter');
  const collapseAllCardsBtn = document.getElementById('collapseAllCards');
  const expandAllCardsBtn = document.getElementById('expandAllCards');

  let shots = []; // includes {collapsed:boolean}
  let mode = 'list';
  let renderCount = 0;
  const BATCH_SIZE = Infinity;

  const readAsDataURL = (file)=> new Promise((res, rej)=>{
    const fr = new FileReader(); fr.onerror = rej; fr.onload = ()=> res(fr.result); fr.readAsDataURL(file);
  });

  async function downscale(dataUrl, maxW=1280, maxH=1280, q=.85){
    const img = new Image(); img.decoding='async'; img.src = dataUrl; await img.decode().catch(()=>{});
    const r = Math.min(1, maxW/img.width, maxH/img.height);
    const cw = Math.round(img.width*r), ch = Math.round(img.height*r);
    const c = document.createElement('canvas'); c.width=cw; c.height=ch;
    const ctx = c.getContext('2d'); ctx.imageSmoothingQuality='high'; ctx.drawImage(img,0,0,cw,ch);
    return c.toDataURL('image/jpeg', q);
  }

  function guessFormatFromFilename(name){
    const m = String(name).match(/\.([a-z0-9]+)$/i); if(!m) return 'IMG';
    const ext = m[1].toUpperCase(); return ext==='JPG' ? 'JPEG' : ext;
  }
  function inferFormat(file){
    if(file && file.type){ const [,ext]=file.type.split('/'); return ext?ext.toUpperCase():guessFormatFromFilename(file.name) }
    return guessFormatFromFilename(file?.name||'');
  }

  function inferTimecode(name){
    const base = name.replace(/\.[^.]+$/,'');
    const m = base.match(/(?:^|[_\- ])(\d{1,2})[._-](\d{2})[._-](\d{2})(?:[._-](\d{2}))?/);
    if(!m) return ''; const hh=m[1].padStart(2,'0'), mm=m[2], ss=m[3], ff=m[4]||'00';
    return `${hh}:${mm}:${ss}:${ff}`;
  }
  function tcToFrames(tc, fps){
    if(!tc) return null;
    const m = tc.match(/^(\d{1,2}):(\d{2}):(\d{2})(?::(\d{2}))?$/); if(!m) return null;
    const hh=+m[1], mm=+m[2], ss=+m[3], ff=+(m[4]||0);
    return Math.round(((hh*3600+mm*60+ss)*fps)+ff);
  }
  function framesToTC(frames, fps){
    frames = Math.max(0, Math.round(frames));
    const totalSec = Math.floor(frames / fps), ff = frames % fps;
    const hh = Math.floor(totalSec/3600), mm=Math.floor((totalSec%3600)/60), ss=totalSec%60;
    return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}:${String(ff).padStart(2,'0')}`;
  }

// Detect if a WebP is animated by reading RIFF chunks (VP8X flag or ANIM chunk)
async function isAnimatedWebP(file){
  try{
    const buf = await file.arrayBuffer();
    const u8 = new Uint8Array(buf);
    const len = u8.length;
    const tagAt = (i)=> String.fromCharCode(u8[i],u8[i+1],u8[i+2],u8[i+3]||0);
    const u32LE = (i)=> (u8[i] | (u8[i+1]<<8) | (u8[i+2]<<16) | (u8[i+3]<<24)>>>0);

    if(len < 16) return false;
    if(tagAt(0) !== 'RIFF' || tagAt(8) !== 'WEBP') return false;
    let off = 12;
    while(off + 8 <= len){
      const tag = tagAt(off);
      const size = u32LE(off+4);
      const dataOff = off + 8;
      if(tag === 'VP8X' && dataOff + 1 < len){
        const flags = u8[dataOff];
        // Bit 1 (0x02) indicates animation present
        if((flags & 0x02) !== 0) return true;
      }
      
// WebP canvas player using WebCodecs ImageDecoder
window._webpPlayers = window._webpPlayers || new Map();
class WebPPlayer {
  constructor(canvas, url){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.url = url;
    this.frames = [];
    this.durations = [];
    this.size = null;
    this.index = 0;
    this.playing = false;
    this.t = null;
  }
  


async load(){
    if (!('ImageDecoder' in window)) throw new Error('WebCodecs ImageDecoder not supported in this browser.');
    const res = await fetch(this.url);
    const blob = await res.blob();
    const data = new Uint8Array(await blob.arrayBuffer());
    const decoder = new ImageDecoder({data, type:'image/webp'});
    await decoder.tracks.ready;
    const frameCount = decoder.tracks.selectedTrack?.frameCount ?? decoder.completeFrameCount ?? decoder.frameCount ?? 0;
    const count = Math.max(frameCount || 0, 1);
    this.frames = new Array(count);
    this.durations = new Array(count);
    for (let i=0; i<count; i++){
      const {image} = await decoder.decode({frameIndex:i});
      const bmp = await createImageBitmap(image);
      this.frames[i] = bmp;
      // duration is in milliseconds per spec; default 100ms if missing
      this.durations[i] = (typeof image.duration === 'number' && image.duration>0) ? image.duration : 100;
      this.size = {w: image.displayWidth || bmp.width, h: image.displayHeight || bmp.height};
      image.close();
    }
    decoder.close();
    // fit canvas
    this.canvas.width = this.size.w;
    this.canvas.height = this.size.h;
    this.draw(0);
  }
  draw(i){
    this.index = i|0;
    if(!this.frames.length) return;
    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    const frame = this.frames[this.index % this.frames.length];
    if(frame) this.ctx.drawImage(frame, 0, 0);
  }
  play(onIndex){
    if(this.playing || !this.frames.length) return;
    this.playing = true;
    const tick = () => {
      if(!this.playing) return;
      this.draw(this.index);
      try{ onIndex && onIndex(this.index); }catch{}
      const delay = this.durations[this.index] || 100;
      this.index = (this.index + 1) % this.frames.length;
      this.t = setTimeout(tick, delay);
    };
    tick();
  }
  pause(){
    this.playing = false;
    if(this.t){ clearTimeout(this.t); this.t = null; }
  }
  goto(i, onIndex){
    this.pause();
    this.draw(Math.max(0, Math.min(this.frames.length-1, i|0)));
    try{ onIndex && onIndex(this.index); }catch{}
  }
  dispose(){
    this.pause();
    for(const bmp of this.frames){ try{ bmp.close?.(); }catch{} }
    this.frames = [];
  }
}
window.WebPPlayer = WebPPlayer;

if(tag === 'ANIM') return true;
      off = dataOff + size + (size & 1); // chunks are padded to even size
    }
    return false;
  }catch{ return false; }
}

  async function videoPoster(file, time=0.1){
    return new Promise((resolve)=>{
      const url = URL.createObjectURL(file), v = document.createElement('video');
      v.preload='metadata'; v.muted=true; v.playsInline=true; v.src=url;
      v.addEventListener('loadedmetadata', ()=>{
        const c=document.createElement('canvas'); c.width=v.videoWidth; c.height=v.videoHeight; const ctx=c.getContext('2d');
        const grab = ()=>{ try{ ctx.drawImage(v,0,0,c.width,c.height); resolve(c.toDataURL('image/jpeg',.85)); }catch{ resolve(''); } URL.revokeObjectURL(url); };
        if(isFinite(v.duration)&&v.duration>0){ v.currentTime=Math.min(time,Math.max(0,v.duration-0.2)); v.addEventListener('seeked',grab,{once:true}); }
        else { v.addEventListener('loadeddata',grab,{once:true}); }
      }, {once:true});
      v.addEventListener('error', ()=>{ URL.revokeObjectURL(url); resolve(''); }, {once:true});
    });
  }

  function setPageModeButtonsState(){ const on = mode==='page'; collapseAllCardsBtn.disabled=!on; expandAllCardsBtn.disabled=!on; }
  modeListBtn.addEventListener('click', ()=>{ mode='list'; modeListBtn.classList.add('active'); modePageBtn.classList.remove('active'); listSection.classList.remove('hidden'); pageSection.classList.add('hidden'); setPageModeButtonsState(); render(); });
  modePageBtn.addEventListener('click', ()=>{ mode='page'; modePageBtn.classList.add('active'); modeListBtn.classList.remove('active'); listSection.classList.add('hidden'); pageSection.classList.remove('hidden'); setPageModeButtonsState(); resetInfinite(); render(); });
  starFilter.addEventListener('change', ()=>{ resetInfinite(); render(); });
  setPageModeButtonsState();

  collapseAllCardsBtn.addEventListener('click', ()=>{ shots.forEach(s=>s.collapsed=true); render(); });
  expandAllCardsBtn.addEventListener('click', ()=>{ shots.forEach(s=>s.collapsed=false); render(); });

  function filteredShots(){ return starFilter.checked ? shots.filter(s=>s.starred) : shots; }

  function render(){ mode==='list' ? renderList() : renderPage(); }

  function renderList(){
    tbody.innerHTML='';
    filteredShots().forEach((s,i)=>{
      const tr = rowTpl.content.firstElementChild.cloneNode(true); tr.dataset.id=s.id;
      tr.querySelector('.idx').textContent=String(i+1).padStart(3,'0');
      const thumbImg = tr.querySelector('img.thumb');
      thumbImg.src = s.thumb || '';
      if (s.imageURL){
        thumbImg.addEventListener('mouseenter', ()=>{ thumbImg.src = s.imageURL; });
        thumbImg.addEventListener('mouseleave', ()=>{ thumbImg.src = s.thumb || ''; });
        thumbImg.title = 'Hover to preview';
      }
      tr.querySelector('[data-filename]').textContent=s.filename;
      tr.querySelector('.selbox').checked=!!s.selected;
      tr.querySelector('.title').value=s.title||''; tr.querySelector('.starttc').value=s.startTC||''; tr.querySelector('.endtc').value=s.endTC||'';
      tr.querySelector('.desc').value=s.desc||''; tr.querySelector('.camera').value=s.camera||''; tr.querySelector('.lens').value=s.lens||'';
      tr.querySelector('.take').value=s.take||''; tr.querySelector('.notes').value=s.notes||'';
      tr.querySelector('.kind').textContent=s.format||guessFormatFromFilename(s.filename);
      const starEl=tr.querySelector('.starlist'); starEl.textContent=s.starred?'★':'☆'; starEl.style.cursor='pointer';
      starEl.addEventListener('click',()=>{ s.starred=!s.starred; render(); });

      tr.addEventListener('dragstart',(e)=>{ tr.classList.add('dragging'); e.dataTransfer.setData('text/plain',s.id); });
      tr.addEventListener('dragend',()=> tr.classList.remove('dragging'));
      tr.addEventListener('dragover',(e)=>{ e.preventDefault(); tr.classList.add('ghost'); });
      tr.addEventListener('dragleave',()=> tr.classList.remove('ghost'));
      tr.addEventListener('drop',(e)=>{ e.preventDefault(); tr.classList.remove('ghost'); reorderById(e.dataTransfer.getData('text/plain'), s.id); });

      tr.querySelector('.selbox').addEventListener('change',e=> s.selected=e.target.checked);
      tr.querySelector('.title').addEventListener('input',e=> s.title=e.target.value);
      tr.querySelector('.starttc').addEventListener('input',e=> s.startTC=e.target.value);
      tr.querySelector('.endtc').addEventListener('input',e=> s.endTC=e.target.value);
      tr.querySelector('.desc').addEventListener('input',e=> s.desc=e.target.value);
      tr.querySelector('.camera').addEventListener('input',e=> s.camera=e.target.value);
      tr.querySelector('.lens').addEventListener('input',e=> s.lens=e.target.value);
      tr.querySelector('.take').addEventListener('input',e=> s.take=e.target.value);
      tr.querySelector('.notes').addEventListener('input',e=> s.notes=e.target.value);

      tr.querySelector('.del').addEventListener('click',()=> removeShot(s.id));
      tbody.appendChild(tr);
    });
  }

  function resetInfinite(){ renderCount = Math.min(BATCH_SIZE, filteredShots().length); }
  window.addEventListener('scroll',()=>{
    if(mode!=='page') return;
    const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 800);
    if(nearBottom){ renderCount = Math.min(filteredShots().length, renderCount + BATCH_SIZE); renderPage(); }
  });

  function renderPage(){
    const list = filteredShots(); if(renderCount===0) resetInfinite();
    pageContainer.innerHTML='';
    list.slice(0,renderCount).forEach((s,i)=>{
      const card = cardTpl.content.firstElementChild.cloneNode(true); card.dataset.id=s.id;
      card.querySelector('.idxbadge').textContent=`#${String(i+1).padStart(3,'0')}`;
      const starEl=card.querySelector('.star'); starEl.classList.toggle('on',!!s.starred); starEl.textContent=s.starred?'★':'☆';
      starEl.addEventListener('click',()=>{ s.starred=!s.starred; render(); });

      const titleInput=card.querySelector('.title-input'); titleInput.value=s.title||''; titleInput.addEventListener('input',e=> s.title=e.target.value);

      const img=card.querySelector('.media-img'); const vid=card.querySelector('.media-vid');
      const replaceBtn=card.querySelector('.replace'); const replaceInput=card.querySelector('.replaceInput');
      if(s.mediaType==='video' && s.previewURL){ 
        vid.classList.remove('hidden'); img.classList.add('hidden'); 
        // hide canvas/controls if present
        const holder = img.parentElement;
        const canvas = holder.querySelector('canvas.webpCanvas'); if(canvas) canvas.classList.add('hidden');
        const ctrls = holder.querySelector('.webp-controls'); if(ctrls) ctrls.classList.add('hidden');
        vid.src=s.previewURL; vid.poster=s.thumb||''; 
      }
      else { 
        const holder = img.parentElement;
        let canvas = holder.querySelector('canvas.webpCanvas');
        let ctrls = holder.querySelector('.webp-controls');
        if(!canvas){ canvas = document.createElement('canvas'); canvas.className='webpCanvas hidden'; img.after(canvas); }
        if(!ctrls){
          ctrls = document.createElement('div'); ctrls.className='webp-controls hidden';
          ctrls.innerHTML = `
            <button type="button" data-act="play">Play</button>
            <button type="button" data-act="pause">Pause</button>
            <button type="button" data-act="stop">Stop</button>
            <label style="display:flex;align-items:center;gap:.5rem;">
              <span>Frame</span>
              <input type="range" min="0" max="0" value="0" step="1" data-act="slider">
              <span data-act="label">0/0</span>
            </label>`;
          canvas.after(ctrls);
        }
        const playBtn = ctrls.querySelector('[data-act=play]');
        const pauseBtn = ctrls.querySelector('[data-act=pause]');
        const stopBtn = ctrls.querySelector('[data-act=stop]');
        const slider = ctrls.querySelector('[data-act=slider]');
        const label = ctrls.querySelector('[data-act=label]');
        
        if (s.imageURL){
          // Use canvas + controls
          img.classList.add('hidden'); vid.classList.add('hidden');
          canvas.classList.remove('hidden'); ctrls.classList.remove('hidden');
          // Show placeholder while loading
          canvas.getContext('2d').fillStyle = '#111';
          canvas.width = img.naturalWidth||320; canvas.height = img.naturalHeight||180;
          canvas.getContext('2d').fillRect(0,0,canvas.width,canvas.height);
          canvas.getContext('2d').fillStyle='#999';
          canvas.getContext('2d').fillText('Loading WebP…', 10, 20);

          window._webpPlayers = window._webpPlayers || new Map();
          let player = window._webpPlayers.get(s.id);
          const ensureLoaded = async ()=>{
            if (typeof WebPPlayer === 'undefined'){
              // Wait for the player class to be defined, then try again
              const start = Date.now();
              const poll = ()=>{
                if (typeof WebPPlayer !== 'undefined'){ ensureLoaded(); return; }
                if (Date.now() - start > 5000){ console.warn('WebPPlayer not available'); return; }
                setTimeout(poll, 50);
              };
              poll();
              return;
            }
            if (player && player.url !== s.imageURL){
              try{ player.dispose(); }catch{}
              window._webpPlayers.delete(s.id);
              player = null;
            }
            if(!player){
              player = new WebPPlayer(canvas, s.imageURL);
              window._webpPlayers.set(s.id, player);
              try{ await player.load(); }catch(e){ console.warn('WebP load failed', e); }
              slider.max = String(Math.max(0, player.frames.length-1));
              slider.value = "0";
              label.textContent = `1/${player.frames.length}`;
            }else{
              slider.max = String(Math.max(0, player.frames.length-1));
              label.textContent = `${(player.index+1)}/${player.frames.length}`;
              slider.value = String(player.index);
            }
          };
          ensureLoaded();
          
          const updateUIFromIndex = (idx)=>{
            try{ const p=(window._webpPlayers && window._webpPlayers.get(s.id))||null; label.textContent = `${(idx+1)}/${p?p.frames.length:0}`; }catch{ label.textContent = `${idx+1}`; }
            if (document.activeElement !== slider) slider.value = String(idx);
          };
          
          playBtn.onclick = ()=>{ const p=(window._webpPlayers && window._webpPlayers.get(s.id))||null; if(p) p.play(updateUIFromIndex); };
          pauseBtn.onclick = ()=>{ const p=(window._webpPlayers && window._webpPlayers.get(s.id))||null; if(p) p.pause(); };
          stopBtn.onclick = ()=>{ const p=(window._webpPlayers && window._webpPlayers.get(s.id))||null; if(p) p.goto(0, updateUIFromIndex); };
          slider.oninput = ()=>{ const p=(window._webpPlayers && window._webpPlayers.get(s.id))||null; if(p) p.seek(parseInt(slider.value||'0',10), updateUIFromIndex); };
          
          // Store cleanup hook on holder for when navigating away
          holder._disposeWebP = ()=>{ try{ player && player.dispose(); }catch{}; window._webpPlayers.delete(s.id); };
        }else{
          // Fallback to static poster behavior
          if (holder._disposeWebP){ try{ holder._disposeWebP(); }catch{}; holder._disposeWebP=null; }
          canvas.classList.add('hidden'); ctrls.classList.add('hidden');
          img.classList.remove('hidden'); vid.classList.add('hidden');
          img.src = s.thumb || '';
        }
      }
      replaceBtn.addEventListener('click',()=> replaceInput.click());
      replaceInput.addEventListener('change',async (e)=>{ const f=e.target.files[0]; if(!f) return; await replaceMedia(s,f); render(); });

      const toggleBtn=card.querySelector('.toggleFields');
      if(s.collapsed) card.classList.add('fields-collapsed'); else card.classList.remove('fields-collapsed');
      toggleBtn.addEventListener('click',(e)=>{
        const multi = e.altKey||e.metaKey||e.ctrlKey;
        if(multi){ const ns=!s.collapsed; shots.forEach(x=> x.collapsed=ns); }
        else s.collapsed=!s.collapsed;
        render();
      });

      card.querySelector('.starttc').value=s.startTC||'';
      card.querySelector('.endtc').value=s.endTC||'';
      card.querySelector('.take').value=s.take||'';
      card.querySelector('.camera').value=s.camera||'';
      card.querySelector('.lens').value=s.lens||'';
      card.querySelector('.desc').value=s.desc||'';
      card.querySelector('.filename').textContent=s.filename;
      card.querySelector('.kind').textContent=s.format||guessFormatFromFilename(s.filename);

      ['starttc','endtc','take','camera','lens','desc'].forEach(cls=>{
        card.querySelector('.'+cls).addEventListener('input',e=> s[cls==='starttc'?'startTC':cls==='endtc'?'endTC':cls]=e.target.value);
      });

      const dragHandle=card.querySelector('.drag-handle');
      dragHandle.addEventListener('mousedown',()=> card.setAttribute('draggable','true'));
      dragHandle.addEventListener('mouseup',()=> card.removeAttribute('draggable'));
      card.addEventListener('dragstart',(e)=>{ card.classList.add('dragging'); e.dataTransfer.setData('text/plain',s.id); });
      card.addEventListener('dragend',()=> card.classList.remove('dragging'));
      card.addEventListener('dragover',(e)=>{ e.preventDefault(); card.classList.add('ghost'); });
      card.addEventListener('dragleave',()=> card.classList.remove('ghost'));
      card.addEventListener('drop',(e)=>{ e.preventDefault(); card.classList.remove('ghost'); reorderById(e.dataTransfer.getData('text/plain'), s.id); });

      card.querySelector('.del').addEventListener('click',()=> removeShot(s.id));
      pageContainer.appendChild(card);
    });
  }

  function reorderById(srcId,destId){
    if(!srcId||srcId===destId) return;
    const from=shots.findIndex(x=>x.id===srcId), to=shots.findIndex(x=>x.id===destId);
    if(from<0||to<0) return; const [moved]=shots.splice(from,1); shots.splice(to,0,moved); render();
  }
  function removeShot(id){
    const s=shots.find(x=>x.id===id);
    if(s){
      if(s.mediaType==='video'&&s.previewURL) try{ URL.revokeObjectURL(s.previewURL);}catch{}
      if(s.imageURL) try{ URL.revokeObjectURL(s.imageURL);}catch{}
    }
    shots=shots.filter(x=>x.id!==id); render();
  }

  // ingest
  fileInput.addEventListener('change', async (e)=>{ await addFiles(e.target.files); fileInput.value=''; });
  ['dragenter','dragover'].forEach(evt=> dz.addEventListener(evt,(e)=>{ e.preventDefault(); dz.classList.add('hover'); }));
  ['dragleave','drop'].forEach(evt=> dz.addEventListener(evt,(e)=>{ e.preventDefault(); dz.classList.remove('hover'); }));
  dz.addEventListener('drop', async (e)=>{ await addFiles(e.dataTransfer.files); });

  async function addFiles(list){
  for (const f of [...list]){
    if(!f.type || !(f.type.startsWith('image/')||f.type.startsWith('video/'))) continue;
    if(f.type.startsWith('image/')){
      if (f.type === 'image/webp'){
        const [dataUrl, anim] = await Promise.all([readAsDataURL(f), isAnimatedWebP(f)]);
        const thumb = await downscale(dataUrl,1600,1600,.85);
        const url = URL.createObjectURL(f);
        shots.push({
          id: crypto.randomUUID(),
          filename: f.name,
          format: inferFormat(f),
          mediaType: 'image',
          thumb,
          imageURL: url,
          isAnimated: !!anim,
          title: '',
          startTC: '',
          endTC: '',
          desc: '',
          camera: '',
          lens: '',
          take: '',
          notes: '',
          selected: false,
          starred: false,
          collapsed: true
        });
      }else{
        const dataUrl = await readAsDataURL(f);
        const thumb  = await downscale(dataUrl,1600,1600,.85);
        shots.push({
          id: crypto.randomUUID(),
          filename: f.name,
          format: inferFormat(f),
          mediaType: 'image',
          thumb,
          isAnimated: false,
          title: '',
          startTC: '',
          endTC: '',
          desc: '',
          camera: '',
          lens: '',
          take: '',
          notes: '',
          selected: false,
          starred: false,
          collapsed: true
        });
      }
    }else{
      const poster = await videoPoster(f) || '';
      const url = URL.createObjectURL(f);
      shots.push({
        id: crypto.randomUUID(),
        filename: f.name,
        format: inferFormat(f),
        mediaType: 'video',
        previewURL: url,
        thumb: poster,
        title: '',
        startTC: '',
        endTC: '',
        desc: '',
        camera: '',
        lens: '',
        take: '',
        notes: '',
        selected: false,
        starred: false,
        collapsed: true
      });
    }
  }
  render(); document.querySelector('table')?.scrollIntoView({behavior:'smooth'});
}

  async function replaceMedia(shot,file){
  if(!file || !(file.type && (file.type.startsWith('image/')||file.type.startsWith('video/')))) return;
  if(shot.mediaType==='video' && shot.previewURL) try{ URL.revokeObjectURL(shot.previewURL);}catch{}
  if(shot.imageURL) { try{ URL.revokeObjectURL(shot.imageURL); }catch{} }
  shot.filename=file.name; shot.format=inferFormat(file);
  if(file.type.startsWith('image/')){
    if (file.type === 'image/webp'){
      const [dataUrl, anim] = await Promise.all([readAsDataURL(file), isAnimatedWebP(file)]);
      const thumb=await downscale(dataUrl,1600,1600,.85);
      shot.mediaType='image'; shot.thumb=thumb; delete shot.previewURL;
      shot.isAnimated=!!anim;
      shot.imageURL = URL.createObjectURL(file);
    }else{
      const dataUrl=await readAsDataURL(file); const thumb=await downscale(dataUrl,1600,1600,.85);
      shot.mediaType='image'; shot.thumb=thumb; delete shot.previewURL; shot.isAnimated=false;
      if(shot.imageURL){ try{ URL.revokeObjectURL(shot.imageURL);}catch{} } delete shot.imageURL;
    }
  }else{
    const poster=await videoPoster(file)||''; shot.mediaType='video'; shot.previewURL=URL.createObjectURL(file); shot.thumb=poster; shot.isAnimated=false;
    if(shot.imageURL){ try{ URL.revokeObjectURL(shot.imageURL);}catch{} } delete shot.imageURL;
  }
}

  // selection
  selectAllBtn.addEventListener('click',()=>{ shots.forEach(s=>s.selected=true); render(); });
  deselectAllBtn.addEventListener('click',()=>{ shots.forEach(s=>s.selected=false); render(); });
  deleteSelBtn.addEventListener('click',()=>{ shots.filter(s=>s.selected).map(s=>s.id).forEach(removeShot); });
  clearAllBtn.addEventListener('click',()=>{ if(confirm('Remove all items?')){ shots.forEach(s=>{ if(s.mediaType==='video'&&s.previewURL) try{URL.revokeObjectURL(s.previewURL);}catch{}; if(s.imageURL) try{URL.revokeObjectURL(s.imageURL);}catch{} }); shots=[]; render(); }});

  // batch replace (not append)
  applyBatchBtn.addEventListener('click',()=>{
    const title=batchTitle.value.trim(), take=batchTake.value.trim(), cam=batchCamera.value.trim(), len=batchLens.value.trim(),
          note=batchNotes.value.trim(), desc=batchDesc.value.trim();
    shots.forEach(s=>{ if(!s.selected) return;
      if(title) s.title=title; if(take) s.take=take; if(cam) s.camera=cam; if(len) s.lens=len; if(note) s.notes=note; if(desc) s.desc=desc; });
    render();
  });

  // timecode parse
  parseTCBtn.addEventListener('click',()=>{
    const modeSel=tcMode.value, fps=parseInt(fpsInput.value)||24, defDur=Math.max(1,parseInt(defaultDurInput.value)||2);
    if(modeSel==='fromName'){
      shots.forEach(s=>{ const tc=inferTimecode(s.filename); if(tc){ s.startTC=tc; s.endTC=''; } });
    }else{
      const nameFrames=shots.map(s=> tcToFrames(inferTimecode(s.filename), fps));
      const durations=shots.map((_,i)=>{ const a=nameFrames[i], b=nameFrames[i+1]; return (a!=null && b!=null && b>a) ? (b-a) : defDur*fps; });
      if(durations.length && !durations[durations.length-1]) durations[durations.length-1]=defDur*fps;
      let acc=0; shots.forEach((s,i)=>{ const d=durations[i]||defDur*fps; s.startTC=framesToTC(acc,fps); s.endTC=framesToTC(acc+d,fps); acc+=d; });
    }
    render();
  });

  // export/import
  exportJSONBtn.addEventListener('click',()=>{
    const safe=shots.map(({previewURL, imageURL, ...rest})=>rest);
    const data={meta:{app:'shotlist-maker',v:5,exported:new Date().toISOString()}, shots:safe};
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const a=document.createElement('a');
    a.href=URL.createObjectURL(blob); a.download='shotlist.json'; a.click(); URL.revokeObjectURL(a.href);
  });
  importJSONInput.addEventListener('change',async (e)=>{
    const f=e.target.files[0]; if(!f) return;
    try{
      const data=JSON.parse(await f.text());
      if(Array.isArray(data.shots)){
        shots=data.shots.map(s=>({selected:false, starred:false, mediaType:'image', collapsed:true, ...s,
          startTC:s.startTC||(s.timecode||''), format:s.format||guessFormatFromFilename(s.filename)}));
        resetInfinite(); render();
      }else alert('JSON missing "shots" array.');
    }catch{ alert('Failed to import JSON.'); }
    importJSONInput.value='';
  });


// Ensure WebPPlayer exists early (runs before main script)
(function(){
  if ('WebPPlayer' in window) return;
  window._webpPlayers = window._webpPlayers || new Map();
  // Minimal WebP canvas player using WebCodecs
  class WebPPlayer {
    constructor(canvas, url){
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.url = url;
      this.frames = [];
      this.durations = [];
      this.size = null;
      this.index = 0;
      this.playing = false;
      this.t = null;
    }
    async load(){
      if (!('ImageDecoder' in window)) throw new Error('WebCodecs ImageDecoder not supported');
      const res = await fetch(this.url);
      const blob = await res.blob();
      const data = new Uint8Array(await blob.arrayBuffer());
      const decoder = new ImageDecoder({data, type:'image/webp'});
      await decoder.tracks.ready;
      const frameCount = decoder.tracks.selectedTrack?.frameCount ?? decoder.completeFrameCount ?? decoder.frameCount ?? 0;
      const count = Math.max(frameCount || 0, 1);
      this.frames = new Array(count);
      this.durations = new Array(count);
      for (let i=0; i<count; i++){
        const {image} = await decoder.decode({frameIndex:i});
        const bmp = await createImageBitmap(image);
        this.frames[i] = bmp;
        this.durations[i] = (typeof image.duration === 'number' && image.duration>0) ? image.duration : 100;
        this.size = {w: image.displayWidth || bmp.width, h: image.displayHeight || bmp.height};
        image.close();
      }
      decoder.close();
      this.canvas.width = this.size.w;
      this.canvas.height = this.size.h;
      this.draw(0);
    }
    draw(i){
      this.index = i|0;
      if(!this.frames.length) return;
      this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
      const frame = this.frames[this.index % this.frames.length];
      if(frame) this.ctx.drawImage(frame, 0, 0);
    }
    play(onIndex){
      if(this.playing || !this.frames.length) return;
      this.playing = true;
      const tick = () => {
        if(!this.playing) return;
        this.draw(this.index);
        try{ onIndex && onIndex(this.index); }catch{}
        const delay = this.durations[this.index] || 100;
        this.index = (this.index + 1) % this.frames.length;
        this.t = setTimeout(tick, delay);
      };
      tick();
    }
    pause(){
      this.playing = false;
      if(this.t){ clearTimeout(this.t); this.t = null; }
    }
    goto(i, onIndex){
      this.pause();
      this.draw(Math.max(0, Math.min(this.frames.length-1, i|0)));
      try{ onIndex && onIndex(this.index); }catch{}
    }
    seek(i, onIndex){
      this.index = Math.max(0, Math.min(this.frames.length-1, i|0));
      this.draw(this.index);
      try{ onIndex && onIndex(this.index); }catch{}
    }
    dispose(){
      this.pause();
      for(const bmp of this.frames){ try{ bmp.close?.(); }catch{} }
      this.frames = [];
    }
  }
  window.WebPPlayer = WebPPlayer;
})();

// print
printBtn.addEventListener('click',()=>{
  if(shots.length===0){ alert('No shots to print.'); return; }
  const list=filteredShots(), w=window.open('','_blank');
  const styles=`@page{size:A4;margin:14mm} body{font:12px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#111}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px} .card{break-inside:avoid;border:1px solid #d7dae0;border-radius:8px;padding:8px}
    .head{display:flex;justify-content:space-between;align-items:center;font-weight:600;margin-bottom:6px;font-size:11px}
    .thumb{width:100%;height:140px;object-fit:cover;background:#000;border-radius:4px}
    .meta{font-size:10px;color:#333;margin-top:4px} .label{color:#6b7280} h1{font-size:14px;margin:0 0 8px} .note{font-size:10px;color:#555;margin-bottom:10px}
    .desc{white-space:pre-wrap}`;
  const title=document.title, time=new Date().toLocaleString();
  const html=`<!doctype html><html><head><meta charset="utf-8"><title>${title} — Print</title><style>${styles}</style></head><body>
    <h1>Shot List</h1><div class="note">Generated ${time}. Use your browser’s <b>Save as PDF</b>.</div><div class="grid">${
      list.map((s,i)=>`
        <div class="card">
          <div class="head"><div>#${String(i+1).padStart(3,'0')} ${s.starred?'★':''} — ${escapeHtml(s.title||'')}</div><div>${
            escapeHtml((s.startTC||'')+(s.endTC? ' — '+s.endTC : ''))}</div></div>
          <img class="thumb" src="${s.thumb}" alt="thumb">
          <div class="meta"><span class="label">File:</span> ${escapeHtml(s.filename)} &nbsp; <span class="label">Type:</span> ${escapeHtml(s.format||'')}</div>
          <div class="meta"><span class="label">Camera:</span> ${escapeHtml(s.camera||'')} &nbsp; <span class="label">Lens:</span> ${escapeHtml(s.lens||'')}</div>
          <div class="meta"><span class="label">Take:</span> ${escapeHtml(s.take||'')}</div>
          <div class="meta desc"><span class="label">Desc:</span> ${escapeHtml(s.desc||'')}</div>
          <div class="meta"><span class="label">Notes:</span> ${escapeHtml(s.notes||'')}</div>
        </div>`).join('')}</div><script>setTimeout(()=>window.print(),400)<\/script></body></html>`;
  w.document.open(); w.document.write(html); w.document.close();
});


// shortcuts (disabled while typing)
document.addEventListener('keydown',(e)=>{
  const tag=(e.target&&e.target.tagName||'').toLowerCase();
  const typing=['input','textarea','select'].includes(tag) || (e.target && e.target.isContentEditable);
  if(typing) return;
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='a'){ e.preventDefault(); shots.forEach(s=>s.selected=true); render(); }
  else if(e.key==='Delete'){ const any=shots.some(s=>s.selected); if(any){ shots=shots.filter(s=>!s.selected); render(); } }
  else if(e.key.toLowerCase()==='p'){ e.preventDefault(); printBtn.click(); }
});

function escapeHtml(str){ return String(str).replace(/[&<>\"']/g,s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[s])); }

// --- Export CSV ---
function csvEscape(v){
if (v === undefined || v === null) return '';
const s = String(v).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
}
function buildCsvRows(list){
const headers = [
  'Index','Filename','Format','MediaType','Title','Description',
  'Camera','Lens','Take','Notes','StartTC','EndTC','Starred'
];
const rows = list.map((s, i) => [
  i+1,
  s.filename||'',
  s.format||'',
  s.mediaType||'',
  s.title||'',
  s.desc||'',
  s.camera||'',
  s.lens||'',
  s.take||'',
  s.notes||'',
  s.startTC||'',
  s.endTC||'',
  s.starred ? 1 : 0
]);
return [headers, ...rows];
}
exportCSVBtn.addEventListener('click', (e)=>{
const list = (typeof filteredShots === 'function' ? filteredShots() : shots) || [];
if(!list.length){ alert('No shots to export.'); return; }
// Alt/Option-click to export ALL, otherwise export current filtered view
const out = (e && e.altKey) ? shots : list;
const rows = buildCsvRows(out);
const csv = rows.map(r => r.map(csvEscape).join(',')).join('\r\n');
const blob = new Blob(["\ufeff"+csv], {type: 'text/csv;charset=utf-8;'}); // BOM for Excel
const a = document.createElement('a');
a.href = URL.createObjectURL(blob);
a.download = 'shotlist.csv';
document.body.appendChild(a);
a.click();
setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
});

</script>
</body>
</html>
