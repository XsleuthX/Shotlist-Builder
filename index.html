<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Shot List Builder</title>
<style>

/* =============================
   Impression — Gold Glass Theme
   (CSS-only; HTML/JS untouched)
   ============================= */
:root{
  --gutter: clamp(18px, 4vw, 48px);
  --bg-0:#0a0e14; --bg-1:#0d121a; --bg-2:#111726;
  --ink:#eef2f7; --ink-dim:#b8c2d6;
  --line:#2a354a; --line-soft:rgba(255,255,255,.06);
  --accent:#e9d6a6;             /* warm gold */
  --accent-strong:#ffd87a;      /* bright gold highlight */
  --ok:#c2c522; --danger:#446cef;
  --shadow-1: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  --r-xl:18px; --r-lg:14px; --r-md:10px; --r-sm:8px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--ink);
  font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  background:
    radial-gradient(1200px 600px at 20% -10%, #1b2436 0%, transparent 60%),
    radial-gradient(1000px 500px at 120% 20%, #132034 0%, transparent 60%),
    linear-gradient(180deg, #080b10, #0a0e14 40%, #0a0e14);
}
/* Scrollbar */
*::-webkit-scrollbar{height:12px;width:12px}
*::-webkit-scrollbar-thumb{background:#1d2636;border:3px solid transparent;border-radius:12px;background-clip:padding-box}
*{scrollbar-color:#1d2636 transparent; scrollbar-width:thin}

/* Header */
header{position:sticky; top:0; z-index:5; backdrop-filter:saturate(140%) blur(8px);
  background:linear-gradient(180deg, rgba(11,15,21,.85), rgba(11,15,21,.65) 70%, rgba(11,15,21,0));
  border-bottom:1px solid var(--line)}
.wrap{max-width:1200px; margin:0 auto; padding:12px var(--gutter)}
h1{margin:0 0 6px; font-size:18px; letter-spacing:.2px}
.sub{color:var(--ink-dim); margin-bottom:10px}


/* Bridge variables for Templates modal */
:root{ --panel: var(--bg-2); --text: var(--ink); --muted: var(--ink-dim); --accent: var(--accent); }
/* Toolbar */
.bar{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
.group{
  display:flex; gap:10px; padding:8px;
  background:rgba(255,255,255,.02);
  border:1px solid var(--line);
  border-radius:var(--r-xl);
  box-shadow:var(--shadow-1);
  backdrop-filter: blur(6px) saturate(120%);
}
.group .label{font-size:12px; color:var(--ink-dim); align-self:center; margin-right:2px; letter-spacing:.2px}

/* Buttons: transparent glass + gold dot */
button,.btn{
  position:relative;
  background:rgba(255,255,255,.04);
  color:var(--ink);
  border:1px solid var(--line);
  padding:10px 14px 10px 32px; border-radius:999px; cursor:pointer;
  box-shadow:var(--shadow-1);
  transition: border-color .15s ease, box-shadow .15s ease, background .15s ease, transform .05s ease;
}
button:hover,.btn:hover{border-color:rgba(255,255,255,.18); background:rgba(255,255,255,.055)}
button:active,.btn:active{transform:translateY(1px)}
button[disabled],.btn[disabled]{opacity:.55; cursor:not-allowed}
/* left gold dot */
button::before,.btn::before{
  content:"";
  position:absolute; left:12px; top:50%; transform:translateY(-50%);
  width:8px; height:8px; border-radius:50%;
  background: radial-gradient(circle at 35% 35%, #fff6d6 0, var(--accent) 50%, #826a2e 100%);
  box-shadow:0 0 0 2px rgba(233,214,166,.18), 0 0 12px rgba(233,214,166,.35);
}
/* Variants */
.btn.ok{border-color:#555b1e; background:(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:rgba(255,222,132,.8); box-shadow:0 6px 18px rgba(255,222,132,.24), font}
.btn.ok::before{
  background:linear-gradient(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:#0b1018; box-shadow:0 6px 18px rgba(255,222,132,.24), inset 0 1px 0 rgba(255,255,255,.25);
                   border-color:rgba(255,222,132,.35)}

.btn.danger{border-color:#8cdbff; background:rgba(#1b637f,.14); color:#d9feff}
.btn.danger::before{background: radial-gradient(circle at 35% 35%, #d9feff 0, #8cdbff 55%, #1b637f 100%); box-shadow:0 0 0 2px rgba(140, 251, 255, 0.18), 0 0 12px rgba(255,140,140,.32)}
.btn.muted{background:rgba(255,255,255,.03)}

/* file input label */
input[type=file]{display:none}
label.filebtn{display:inline-flex; align-items:center; gap:8px}

/* Segmented control */
.seg{display:inline-flex; border:1px solid var(--line); border-radius:999px; overflow:hidden; background:rgba(255,255,255,.03)}
.seg button{border:0; background:transparent; padding:8px 12px; border-right:1px solid var(--line); border-radius:0}
.seg button:last-child{border-right:0}
.seg button.active{background:linear-gradient(180deg, rgba(255,222,132,.8), rgba(255,222,132,.5));
                   color:#0b1018; box-shadow:0 6px 18px rgba(255,222,132,.24), inset 0 1px 0 rgba(255,255,255,.25);
                   border-color:rgba(255,222,132,.35)}
/* Remove dots in segmented buttons */
.seg button::before{display:none}
.webp-controls button::before{display:none}

/* Dropzone */
.dropzone{border:1px dashed var(--line); border-radius:var(--r-xl); padding:24px; text-align:center;
  color:var(--ink-dim); background:rgba(255,255,255,.03); box-shadow:var(--shadow-1); backdrop-filter: blur(4px) saturate(110%)}
.dropzone.hover{border-color:var(--accent-strong); color:var(--ink)}

/* List Mode */
table{width:100%; border-collapse:separate; border-spacing:0 12px}
thead th{text-align:left; font-weight:600; color:var(--ink-dim); padding:0 8px 6px; font-size:12px; letter-spacing:.2px}
tbody tr{background:rgba(255,255,255,.04); border:1px solid var(--line); border-radius:var(--r-xl); box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
tbody tr.dragging{opacity:.65; outline:1px dashed var(--accent-strong)}
td{padding:10px; vertical-align:top}
td.idx{width:56px; text-align:right; color:var(--ink-dim)}
td.drag{width:34px; cursor:grab}
.handle{width:10px; height:24px; background:repeating-linear-gradient(90deg,#9097a6 0 2px,transparent 2px 5px); opacity:.35; border-radius:3px; margin-top:3px}
img.thumb{width:160px; height:90px; object-fit:cover; border-radius:12px; display:block; background:#000; box-shadow:0 6px 16px rgba(0,0,0,.35)}
textarea,input[type=text],input[type=number],select{
  width:100%; background:rgba(255,255,255,.03);
  color:var(--ink); border:1px solid var(--line); border-radius:12px; padding:10px;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.03);
}
textarea{min-height:68px; resize:vertical}
.grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
.mini{font-size:12px; color:var(--ink-dim)}
.tags{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.chip{border:1px solid var(--line); background:rgba(255,255,255,.03); padding:4px 10px; border-radius:999px; font-size:12px; color:#cbd6ea}
.sel{width:36px; text-align:center}
.sel input{transform:scale(1.1); accent-color: var(--accent-strong)}

.topbar{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.spacer{flex:1}

/* Batch panel */
.panel{background:rgba(255,255,255,.035); border:1px solid var(--line); border-radius:var(--r-xl); padding:0; overflow:hidden; box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
.panel .panel-summary{display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; user-select:none}
.panel .panel-summary .title{font-weight:700; letter-spacing:.2px}
details.panel>.panel-summary::marker{content:""}
details.panel>.panel-summary::after{content:"▾"; margin-left:8px; color:var(--ink-dim)}
details.panel[open]>.panel-summary::after{content:"▴"}
.panel .panel-content{padding:12px}

/* Page Mode */
#pageContainer{margin-top:12px}
.page-grid{display:grid; grid-template-columns:repeat(auto-fill,minmax(320px,1fr)); gap:12px}
.card{background:rgba(255,255,255,.04); border:1px solid var(--line); border-radius:var(--r-xl); padding:12px; box-shadow:var(--shadow-1); backdrop-filter: blur(6px)}
.card.dragging{opacity:.65; outline:1px dashed var(--accent-strong)}
.card .head{display:flex; align-items:center; gap:10px; margin-bottom:8px}
.star{cursor:pointer; font-size:18px; line-height:1; user-select:none; color:#c0a96f}
.star.on{color:#ffd166; text-shadow:0 0 12px rgba(255,209,102,.35)}
.idxbadge{font:600 12px/1 ui-sans-serif,system-ui; color:#e6e2d1; padding:6px 8px; border-radius:10px; background:rgba(255,255,255,.03); border:1px solid var(--line)}
.title-input{flex:1; border-radius:12px; background:rgba(255,255,255,.03); border:1px solid var(--line); color:var(--ink)}
.media{position:relative; margin-bottom:10px}
.media img,.media video{width:100%; height:200px; object-fit:cover; border-radius:14px; display:block; background:#000; box-shadow:0 10px 30px rgba(0,0,0,.35)}
.replace{position:absolute; top:10px; right:10px}
.grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}
.bar-l2{display:flex; gap:8px; align-items:center; margin-top:6px}
.format-chip{font-size:11px}
.drag-handle{width:12px; height:24px; background:repeating-linear-gradient(90deg,#9097a6 0 2px,transparent 2px 5px); opacity:.35; border-radius:3px; cursor:grab}
.toggleFields{border-radius:12px; padding:6px 10px}
.fields-collapsed .fields{display:none}
.fields-collapsed .toggleFields::after{content:"▸"}
.toggleFields::after{content:"▾"}

/* Footer */
footer{position:fixed; bottom:0; left:0; right:0; background:linear-gradient(0deg, rgba(11,15,21,.96), rgba(11,15,21,.75), rgba(11,15,21,0)); border-top:1px solid var(--line)}
.footwrap{max-width:1200px; margin:0 auto; padding:12px var(--gutter); display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace; background:rgba(255,255,255,.03); border:1px solid var(--line); padding:2px 8px; border-radius:8px; font-size:12px; color:#e6e2d1; box-shadow:var(--shadow-1)}
.hidden{display:none!important}


/* Toolbar collapse */
body.toolbar-collapsed header .bar,
body.toolbar-collapsed header .sub{ display:none !important; }
#toolbarToggle{ z-index:6 }

/* Dynamic AR for page media */
.card .media{ aspect-ratio: var(--ar, 16/9); }
.card .media img,
.card .media video,
.card .media canvas.webpCanvas{ width:100%; height:100%; object-fit:contain; }

/* ===== Gutter Guard (conflict-proof) ===== */
:root{ --gutter: clamp(18px, 4vw, 48px); }
header > .wrap,
footer > .footwrap{
  max-width: 1320px;
  margin-left: auto; margin-right: auto;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}
main{
  max-width: 1320px;
  margin: 14px auto;
  padding-left: var(--gutter) !important;
  padding-right: var(--gutter) !important;
}
@media (min-width: 1600px){
  header > .wrap, footer > .footwrap, main{ max-width: 1400px; }
}

/* Chevron toolbar toggle - minimal, no circle */
.chevron-toggle{
  appearance:none;
  border:0 !important;
  background:transparent !important;
  box-shadow:none !important;
  outline:none;
  font-size:18px;
  line-height:1;
  cursor:pointer;
  padding:0; margin:0;
  color:var(--ink-dim);
  transform: translateY(0);
}
.chevron-toggle:hover,
.chevron-toggle:focus{
  background:transparent !important;
  box-shadow:none !important;
  color:var(--ink);
}
.chevron-toggle::before,
.chevron-toggle::after{ display:none !important; }


/* Pager */
.pager .btn.muted{ min-width:72px; }
.pager .mini{ opacity:.8; }


/* Chevron toolbar toggle — ultra minimal */
button.chevron-toggle{
  all: unset;
  display: inline-block;
  cursor: pointer;
  font: inherit;
  font-size: 18px;
  line-height: 1;
  color: var(--ink-dim);
}
button.chevron-toggle:hover{ color: var(--ink); }


/* Floating pager (Page Mode only) */
.float-pager{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 84px; /* sit above fixed footer */
  z-index: 50;
  display: flex;
  gap: 12px;
  align-items: center;
  padding: 8px 12px;
  background: rgba(255,255,255,.06);
  border: 1px solid var(--line);
  border-radius: var(--r-xl);
  backdrop-filter: blur(6px) saturate(120%);
  box-shadow: var(--shadow-1);
}
.float-pager .btn.muted{ min-width: 48px; padding: 6px 10px 6px 28px; }
.float-pager .btn.muted::before{ display:none; } /* remove gold dot in tiny buttons */

</style>

<style>
/* Bottom gutter + footer-safe space */
:root{ --gutter: clamp(18px, 4vw, 48px); }
main{
  padding-bottom: max(var(--gutter), 120px) !important; /* leave room for fixed footer and match side gutters */
}
</style>


<style>
/* === Invisible Scrollbars (keep scroll behavior) === */
html, body{
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  -ms-overflow-style: none;           /* IE 10+ & old Edge */
  scrollbar-width: none;              /* Firefox */
  -webkit-overflow-scrolling: touch;  /* iOS momentum */
}
html::-webkit-scrollbar,
body::-webkit-scrollbar{
  width: 0 !important;
  height: 0 !important;
}

/* Optional: hide scrollbars on all inner scroll containers, while preserving scroll */
*{
  -ms-overflow-style: none;
  scrollbar-width: none;
}
*::-webkit-scrollbar{
  width: 0 !important;
  height: 0 !important;
}

/* === Replace button only on hover of media === */
.media .replace{
  opacity: 0;
  pointer-events: none;
  transform: translateY(-4px);
  transition: opacity .18s ease, transform .18s ease, filter .18s ease;
  filter: blur(.2px);
}
.media:hover .replace,
.media:focus-within .replace,
.replace:focus-visible{
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
  filter: none;
}
@media (hover: none) and (pointer: coarse){
  .media .replace{ opacity:1; pointer-events:auto; transform:none; filter:none; }
}
</style>


<style>
.webp-controls{display:flex;gap:.5rem;align-items:center;margin-top:.5rem;flex-wrap:wrap}
.webp-controls button{padding:6px 10px;border-radius:6px;border:1px solid var(--border,#333);background:var(--btn-bg,#222);color:inherit}
.webp-controls input[type=range]{width:240px}
canvas.webpCanvas{max-width:100%;height:auto;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.15);}
</style>


<script>
// Ensure WebPPlayer exists early (runs before main script)
(function(){
  function dataURLtoBlob(dataURL){
    try{
      const [meta,b64] = dataURL.split(',');
      const mime = (meta.match(/^data:([^;]+);base64$/)||[])[1] || 'application/octet-stream';
      const bin=atob(b64); const len=bin.length; const u8=new Uint8Array(len); for(let i=0;i<len;i++) u8[i]=bin.charCodeAt(i);
      return new Blob([u8],{type:mime});
    }catch(e){ console.warn('dataURLtoBlob failed', e); return null; }
  }
  if ('WebPPlayer' in window) return;
  window._webpPlayers = window._webpPlayers || new Map();
  // Minimal WebP canvas player using WebCodecs
  class WebPPlayer {
    constructor(canvas, url){
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.url = url;
      this.frames = [];
      this.durations = [];
      this.size = null;
      this.index = 0;
      this.playing = false;
      this.t = null;
    }
    async load(){
      if (!('ImageDecoder' in window)) throw new Error('WebCodecs ImageDecoder not supported');
      const res = await fetch(this.url);
      const blob = await res.blob();
      const data = new Uint8Array(await blob.arrayBuffer());
      const decoder = new ImageDecoder({data, type:'image/webp'});
      await decoder.tracks.ready;
      const frameCount = decoder.tracks.selectedTrack?.frameCount ?? decoder.completeFrameCount ?? decoder.frameCount ?? 0;
      const count = Math.max(frameCount || 0, 1);
      this.frames = new Array(count);
      this.durations = new Array(count);
      for (let i=0; i<count; i++){
        const {image} = await decoder.decode({frameIndex:i});
        const bmp = await createImageBitmap(image);
        this.frames[i] = bmp;
        this.durations[i] = (typeof image.duration === 'number' && image.duration>0) ? image.duration : 100;
        this.size = {w: image.displayWidth || bmp.width, h: image.displayHeight || bmp.height};
        image.close();
      }
      decoder.close();
      this.canvas.width = this.size.w;
      this.canvas.height = this.size.h;
      this.draw(0);
    }
    draw(i){
      this.index = i|0;
      if(!this.frames.length) return;
      this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
      const frame = this.frames[this.index % this.frames.length];
      if(frame) this.ctx.drawImage(frame, 0, 0);
    }
    play(onIndex){
      if(this.playing || !this.frames.length) return;
      this.playing = true;
      const tick = () => {
        if(!this.playing) return;
        this.draw(this.index);
        try{ onIndex && onIndex(this.index); }catch{}
        const delay = this.durations[this.index] || 100;
        this.index = (this.index + 1) % this.frames.length;
        this.t = setTimeout(tick, delay);
      };
      tick();
    }
    pause(){
      this.playing = false;
      if(this.t){ clearTimeout(this.t); this.t = null; }
    }
    goto(i, onIndex){
      this.pause();
      this.draw(Math.max(0, Math.min(this.frames.length-1, i|0)));
      try{ onIndex && onIndex(this.index); }catch{}
    }
    seek(i, onIndex){
      this.index = Math.max(0, Math.min(this.frames.length-1, i|0));
      this.draw(this.index);
      try{ onIndex && onIndex(this.index); }catch{}
    }
rebindCanvas(newCanvas){
      if (!newCanvas || this.canvas === newCanvas) return;
      this.canvas = newCanvas;
      this.ctx = newCanvas.getContext('2d');
      if (this.size){
        this.canvas.width  = this.size.w;
        this.canvas.height = this.size.h;
      }
      this.draw(this.index|0);
    }

    dispose(){
      this.pause();
      for(const bmp of this.frames){ try{ bmp.close?.(); }catch{} }
      this.frames = [];
    }
  }
  window.WebPPlayer = WebPPlayer;
})();

async function gatherFilesFromDirHandle(dirHandle){
  const files = [];
  async function walk(handle){
    try{
      for await (const [name, h] of handle.entries()){
        if (h.kind === 'file'){
          try{
            const f = await h.getFile();
            if ((f.type||'').startsWith('video/')) files.push(f);
          }catch{}
        }else if (h.kind === 'directory'){
          await walk(h);
        }
      }
    }catch(e){ /* not supported or denied */ }
  }
  await walk(dirHandle);
  return files;
}

function buildSigKey(sig){
  if(!sig) return '';
  const name = (sig.name||'').toLowerCase();
  const size = sig.size||0;
  const lm   = sig.lastModified||0;
  const type = (sig.type||'').toLowerCase();
  return [name, size, lm, type].join('|');
}

async function relinkFromFileList(files, onlyMissing){
  const byStrong = new Map();
  const byName   = new Map();
  for (const f of files){
    const key = buildSigKey({name:f.name,size:f.size,lastModified:f.lastModified,type:f.type});
    byStrong.set(key, f);
    byName.set((f.name||'').toLowerCase(), f);
  }
  let relinked = 0;
  for (const s of shots){
    if (s.mediaType !== 'video') continue;
    if (onlyMissing && s.previewURL) continue;
    const sig = s.sourceHint || {name:s.filename||''};
    const strong = buildSigKey(sig);
    let file = byStrong.get(strong);
    if (!file){
      file = byName.get((sig.name||s.filename||'').toLowerCase());
    }
    if (file){
      try{
        const url = URL.createObjectURL(file);
        s.previewURL = url;
        s.filename = file.name || s.filename;
        s.format = inferFormat(file);
        if (!s.thumb){
          try{ s.thumb = await videoPoster(file) || ''; }catch{}
        }
        s.sourceHint = { name:file.name||'', size:(file.size||0), lastModified:(file.lastModified||0), type:file.type||'' };
        relinked++;
      }catch(e){ console.warn('Failed to relink', e); }
    }
  }
  if (relinked){
    render();
    alert('Relinked ' + relinked + ' video(s).');
  }else{
    alert('No matching videos found in the selected folder.');
  }
}

function countMissingVideos(){
  return shots.filter(s => s.mediaType==='video' && !s.previewURL).length;
}

async function maybeAutoRelinkVideos(){
  const missing = countMissingVideos();
  if (!missing) return;
  const go = confirm('This board has ' + missing + ' video(s) that need re-linking. Pick a folder to scan now?');
  if (go){ await chooseFolderAndRelink({onlyMissing:true}); }
}

async function chooseFolderAndRelink(options){
  options = options || {};
  const onlyMissing = options.onlyMissing !== false; // default true
  let files = [];

  if (window.showDirectoryPicker){
    try{
      const dirHandle = await window.showDirectoryPicker({mode:'read'});
      files = await gatherFilesFromDirHandle(dirHandle);
    }catch(e){ /* user cancelled */ }
  }
  if (!files.length){
    const input = document.createElement('input');
    input.type = 'file';
    input.multiple = true;
    input.accept = 'video/*';
    input.webkitdirectory = true;
    input.directory = true;
    const picked = await new Promise(res => { input.onchange = ()=> res([...input.files]); input.click(); });
    files = picked || [];
  }
  if (!files.length) return;
  await relinkFromFileList(files, onlyMissing);
}


</script>

<style id="drop-follow-box-style">
  #drop-follow-box{
    position:absolute;
    border:2px dashed #3b82f6;
    border-radius:12px;
    pointer-events:none;
    z-index:9999;
    background:rgba(59,130,246,0.06);
    display:none;
  }
</style>

<style>
/* Templates UI removed */
[id*="template"], [class*="template" i], [data-action*="template" i] { display: none !important; }
</style>

</head>
<body>

<script id="drop-follow-box-script">
  (function(){
    if (window.ensureDropBox) return;
    window.ensureDropBox = function ensureDropBox(){
      var box = document.getElementById('drop-follow-box');
      if(!box){
        box = document.createElement('div');
        box.id = 'drop-follow-box';
        document.body.appendChild(box);
      }
      return box;
    };
  })();

async function gatherFilesFromDirHandle(dirHandle){
  const files = [];
  async function walk(handle){
    try{
      for await (const [name, h] of handle.entries()){
        if (h.kind === 'file'){
          try{
            const f = await h.getFile();
            if ((f.type||'').startsWith('video/')) files.push(f);
          }catch{}
        }else if (h.kind === 'directory'){
          await walk(h);
        }
      }
    }catch(e){ /* not supported or denied */ }
  }
  await walk(dirHandle);
  return files;
}

function buildSigKey(sig){
  if(!sig) return '';
  const name = (sig.name||'').toLowerCase();
  const size = sig.size||0;
  const lm   = sig.lastModified||0;
  const type = (sig.type||'').toLowerCase();
  return [name, size, lm, type].join('|');
}

async function relinkFromFileList(files, onlyMissing){
  const byStrong = new Map();
  const byName   = new Map();
  for (const f of files){
    const key = buildSigKey({name:f.name,size:f.size,lastModified:f.lastModified,type:f.type});
    byStrong.set(key, f);
    byName.set((f.name||'').toLowerCase(), f);
  }
  let relinked = 0;
  for (const s of shots){
    if (s.mediaType !== 'video') continue;
    if (onlyMissing && s.previewURL) continue;
    const sig = s.sourceHint || {name:s.filename||''};
    const strong = buildSigKey(sig);
    let file = byStrong.get(strong);
    if (!file){
      file = byName.get((sig.name||s.filename||'').toLowerCase());
    }
    if (file){
      try{
        const url = URL.createObjectURL(file);
        s.previewURL = url;
        s.filename = file.name || s.filename;
        s.format = inferFormat(file);
        if (!s.thumb){
          try{ s.thumb = await videoPoster(file) || ''; }catch{}
        }
        s.sourceHint = { name:file.name||'', size:(file.size||0), lastModified:(file.lastModified||0), type:file.type||'' };
        relinked++;
      }catch(e){ console.warn('Failed to relink', e); }
    }
  }
  if (relinked){
    render();
    alert('Relinked ' + relinked + ' video(s).');
  }else{
    alert('No matching videos found in the selected folder.');
  }
}

function countMissingVideos(){
  return shots.filter(s => s.mediaType==='video' && !s.previewURL).length;
}

async function maybeAutoRelinkVideos(){
  const missing = countMissingVideos();
  if (!missing) return;
  const go = confirm('This board has ' + missing + ' video(s) that need re-linking. Pick a folder to scan now?');
  if (go){ await chooseFolderAndRelink({onlyMissing:true}); }
}

async function chooseFolderAndRelink(options){
  options = options || {};
  const onlyMissing = options.onlyMissing !== false; // default true
  let files = [];

  if (window.showDirectoryPicker){
    try{
      const dirHandle = await window.showDirectoryPicker({mode:'read'});
      files = await gatherFilesFromDirHandle(dirHandle);
    }catch(e){ /* user cancelled */ }
  }
  if (!files.length){
    const input = document.createElement('input');
    input.type = 'file';
    input.multiple = true;
    input.accept = 'video/*';
    input.webkitdirectory = true;
    input.directory = true;
    const picked = await new Promise(res => { input.onchange = ()=> res([...input.files]); input.click(); });
    files = picked || [];
  }
  if (!files.length) return;
  await relinkFromFileList(files, onlyMissing);
}


</script>

<header>
  <div class="wrap">
    <h1>Shot List Builder</h1>

    <div class="sub">Batch drop your shots → reorder → annotate → export as JSON/CSV → print to PDF.</div>

    <div class="bar">
      <div class="group">
        <label class="filebtn btn"><input id="file" type="file" accept="image/*,video/*" multiple> Add Shots</label>
        <button id="selectAll" class="btn">Select All</button>
        <button id="deselectAll" class="btn muted">Deselect</button>
        <button id="deleteSel" class="btn danger">Delete Selected</button>
        <button id="clearAll" class="btn danger">Clear All</button>
      </div>

      <div class="group">
        
<!-- Templates control removed -->

        <button id="exportJSON" class="btn"> Export JSON</button>
        <label class="filebtn btn"><input id="importJSON" type="file" accept="application/json"> Import JSON</label>
        <button id="relinkVideos" class="btn"> Relink Videos</button>
      </div>

      <div class="spacer"></div>

      <div class="group">
        <span class="label">Mode</span>
        <div class="seg">
          <button id="modeList" class="active">List</button>
          <button id="modePage">Page</button>
        </div>
        <label class="mini" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px">
          <input type="checkbox" id="starFilter"> ★ Star Filter
        </label>
        <button id="collapseAllCards" class="btn" disabled title="Collapse all cards in Page Mode">Collapse All</button>
        <button id="expandAllCards" class="btn" disabled title="Expand all cards in Page Mode">Expand All</button>
        <button id="printBtn" class="btn ok"> Print / Save to PDF</button>
        <button id="exportCSV" class="btn ok"> Export CSV</button>
      </div>
        
    </div>
  </div>
</header>

<main>
  
<div style="text-align:center; margin:4px 0 4px;">
  <button id="toolbarToggle" class="chevron-toggle" title="Hide Toolbar" aria-label="Hide Toolbar">▲</button>
</div>

  <div id="dz" class="dropzone">
    <div><strong>Drop your screenshots here</strong> or use <span class="kbd">Add Shots</span>.</div>
  </div>

  <!-- Collapsible Batch Tools -->
  <details id="batchPanel" class="panel" style="margin-top:12px">
    <summary class="panel-summary"><span class="title">Batch Tools</span><span class="spacer"></span><span class="mini">click to show/hide</span></summary>
    <div class="panel-content">
      <div class="topbar">
        <div class="mini">Batch Edit Selected:</div>
        <input type="text" id="batchTitle" placeholder="Shot Title">
        <input type="text" id="batchTake" placeholder="Take">
        <input type="text" id="batchCamera" placeholder="Camera">
        <input type="text" id="batchLens" placeholder="Shot Size">
        <input type="text" id="batchNotes" placeholder="Notes">
        <input type="text" id="batchDesc" placeholder="Description">
        <button id="applyBatch" class="btn">Apply</button>
        <div class="spacer"></div>
        <div class="mini">Timecode:</div>
        <select id="tcMode" title="Timecode Mode">
          <option value="fromName">Use filename TC</option>
          <option value="timeline">Build timeline from 00:00:00:00</option>
        </select>
        <label class="mini">FPS <input id="fps" type="number" value="24" min="1" max="120" style="width:70px"></label>
        <label class="mini">Default dur (s) <input id="defaultDur" type="number" value="2" min="1" max="3600" style="width:80px"></label>
        <button id="parseTC" class="btn">Parse ↻</button>
      </div>
    </div>
  </details>

<!-- Memory Tools -->
<details id="memoryPanel" class="panel" style="margin-top:12px">
  <summary class="panel-summary"><span class="title">Memory Tools</span><span class="spacer"></span>
    <span class="mini" id="memStats">—</span>
  </summary>
  <div class="panel-content">
    <div class="topbar" style="gap:12px; align-items:flex-end;">
      <div class="group" style="flex-wrap:wrap;">
        <span class="label">Actions</span>
        <button id="memPurgeCache" class="btn muted">Free Cache</button>
        <button id="memReleaseURLs" class="btn danger">Release URLs</button>
        <button id="memStripOriginals" class="btn danger">Strip Originals</button>
      </div>
      <div class="group">
        <span class="label">Keep first</span>
        <input id="memKeepN" type="number" value="24" min="0" max="500" style="width:80px">
        <span class="mini">items when releasing</span>
      </div>
      <div class="group">
        <span class="label">Page batch size</span>
        <input id="pageBatchSize" type="number" min="8" max="200" style="width:80px">
        <button id="applyPageBatch" class="btn">Apply</button>
      </div>
    </div>
  </div>
</details>

  <!-- List Mode -->
  <section id="listSection">
    <table style="margin-top:12px">
      <thead>
        <tr>
          <th class="sel"></th><th class="drag"></th><th class="idx">#</th>
          <th>Thumbnail</th><th>Core</th><th>Details</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </section>

  <!-- Page Mode -->
  <section id="pageSection" class="hidden">
    <div id="pageContainer" class="page-grid"></div>
  </section>

  <div id="floatPager" class="float-pager hidden" role="navigation" aria-label="Page navigation">
    <button id="pagePrev" class="btn muted" title="Previous Page" aria-label="Previous Page">◀</button>
    <span id="pageInfo" class="mini" aria-live="polite">Page 1 / 1</span>
    <button id="pageNext" class="btn muted" title="Next Page" aria-label="Next Page">▶</button>
  </div>

</main>

<footer>
  <div class="footwrap mini">
    <div><strong>Shortcuts:</strong></div>
    <div class="kbd">⌘/Ctrl + A</div><div>select all</div>
    <div class="kbd">Delete</div><div>remove selected</div>
    <div class="kbd">P</div><div>print view</div>
  </div>
</footer>

<template id="row">
  <tr draggable="true">
    <td class="sel"><input type="checkbox" class="selbox"></td>
    <td class="drag"><div class="handle" title="Drag to reorder"></div></td>
    <td class="idx"></td>
    <td>
      <img class="thumb" alt="thumb">
      <div class="mini" data-filename></div>
      <div class="mini"><span class="starlist">☆</span> <span class="kind">IMG</span></div>
    </td>
    <td>
      <div class="grid2">
        <div>
          <label class="mini">Shot Title</label>
          <input type="text" class="title">
        </div>
        <div class="grid2">
          <div>
            <label class="mini">Start TC</label>
            <input type="text" class="starttc" placeholder="HH:MM:SS:FF">
          </div>
          <div>
            <label class="mini">End TC</label>
            <input type="text" class="endtc" placeholder="HH:MM:SS:FF">
          </div>
        </div>
      </div>
      <div style="margin-top:8px">
        <label class="mini">Description</label>
        <textarea class="desc" placeholder="Action, purpose, notes..."></textarea>
      </div>
    </td>
    <td>
      <div class="grid2">
        <div>
          <label class="mini">Camera</label>
          <input type="text" class="camera" placeholder="FX3 / iPhone 15 / ...">
        </div>
        <div>
          <label class="mini">Shot Size</label>
          <input type="text" class="lens" placeholder="Wide / CU / ...">
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label class="mini">Take</label>
          <input type="text" class="take" placeholder="A / B / 2nd">
        </div>
        <div>
          <label class="mini">Notes</label>
          <input type="text" class="notes" placeholder="Any extra notes">
        </div>
      </div>
      <div class="tags" style="margin-top:8px">
        <button class="btn danger mini del">Delete</button>
      </div>
    </td>
  </tr>
</template>

<template id="cardTpl">
  <div class="card fields-collapsed" draggable="true">
    <div class="head">
      <span class="star">☆</span>
      <span class="idxbadge">#001</span>
      <input class="title-input" type="text" placeholder="Shot Title">
      <button class="btn toggleFields" title="Show/Hide fields"></button>
      <div class="drag-handle" title="Drag to reorder"></div>
    </div>
    <div class="media">
      <img class="media-img" alt="thumb">
      <video class="media-vid hidden" controls playsinline></video>
      <button class="btn replace">Replace…</button>
      <input class="replaceInput" type="file" accept="image/*,video/*" style="display:none">
    </div>
    <div class="fields">
      <div class="grid3">
        <div>
          <label class="mini">Start TC</label>
          <input type="text" class="starttc" placeholder="HH:MM:SS:FF">
        </div>
        <div>
          <label class="mini">End TC</label>
          <input type="text" class="endtc" placeholder="HH:MM:SS:FF">
        </div>
        <div>
          <label class="mini">Take</label>
          <input type="text" class="take" placeholder="A / B / 2nd">
        </div>
      </div>
      <div class="grid2" style="margin-top:8px">
        <div>
          <label class="mini">Camera</label>
          <input type="text" class="camera" placeholder="FX3 / iPhone 15 / ...">
        </div>
        <div>
          <label class="mini">Shot Size</label>
          <input type="text" class="lens" placeholder="Wide / CU / ...">
        </div>
      </div>
      <div style="margin-top:8px">
        <label class="mini">Description</label>
        <textarea class="desc" placeholder="Action, purpose, notes..."></textarea>
      </div>
      <div class="bar-l2">
        <span class="chip format-chip kind">IMG</span>
        <span class="mini filename"></span>
        <div class="spacer"></div>
        <button class="btn danger mini del">Delete</button>
      </div>
    </div>
  </div>
</template>

<script>
  const fileInput = document.getElementById('file');
  const dz = document.getElementById('dz');
  const tbody = document.getElementById('tbody');
  const rowTpl = document.getElementById('row');
  const cardTpl = document.getElementById('cardTpl');
  const listSection = document.getElementById('listSection');
  const pageSection = document.getElementById('pageSection');
  const pageContainer = document.getElementById('pageContainer');
  const selectAllBtn = document.getElementById('selectAll');
  const deselectAllBtn = document.getElementById('deselectAll');
  const deleteSelBtn = document.getElementById('deleteSel');
  const clearAllBtn = document.getElementById('clearAll');
  const printBtn = document.getElementById('printBtn');
  const exportJSONBtn = document.getElementById('exportJSON');
  const importJSONInput = document.getElementById('importJSON');
  const exportCSVBtn = document.getElementById('exportCSV');
  const relinkVideosBtn = document.getElementById('relinkVideos');
  const parseTCBtn = document.getElementById('parseTC');
  const applyBatchBtn = document.getElementById('applyBatch');
  const batchTitle = document.getElementById('batchTitle');
  const batchTake = document.getElementById('batchTake');
  const batchCamera = document.getElementById('batchCamera');
  const batchLens = document.getElementById('batchLens');
  const batchNotes = document.getElementById('batchNotes');
  const batchDesc = document.getElementById('batchDesc');
  const tcMode = document.getElementById('tcMode');
  const fpsInput = document.getElementById('fps');
  const defaultDurInput = document.getElementById('defaultDur');
  const modeListBtn = document.getElementById('modeList');
  const modePageBtn = document.getElementById('modePage');
  const starFilter = document.getElementById('starFilter');
  const collapseAllCardsBtn = document.getElementById('collapseAllCards');
  const expandAllCardsBtn = document.getElementById('expandAllCards');

  
let shots = [];
window._videoEls = window._videoEls || new Map();

function removeShot(id){
  const i = shots.findIndex(s => s.id === id);
  if (i > -1){
    const s = shots[i];
    try{ s.previewURL && URL.revokeObjectURL(s.previewURL); }catch{}
    try{ s.imageURL && URL.revokeObjectURL(s.imageURL); }catch{}
    try{
      const ve = window._videoEls && window._videoEls.get(s.id);
      if (ve){ try{ ve.pause(); }catch{} window._videoEls.delete(s.id); }
    }catch{}
    shots.splice(i, 1);
    render();
  }
}

async function videoPosterInfo(file, time=0.1){
  return new Promise((resolve)=>{
    const url = URL.createObjectURL(file);
    const v = document.createElement('video');
    v.preload='metadata'; v.muted=true; v.playsInline=true; v.src=url;
    v.addEventListener('loadedmetadata', ()=>{
      const w = v.videoWidth|0, h = v.videoHeight|0;
      const c=document.createElement('canvas'); c.width=w||320; c.height=h||180;
      const ctx=c.getContext('2d');
      const grab = ()=>{ try{ ctx.drawImage(v,0,0,c.width,c.height); resolve({poster:c.toDataURL('image/jpeg',.85), w: w||c.width, h: h||c.height}); }catch{ resolve({poster:'', w, h}); } URL.revokeObjectURL(url); };
      if(isFinite(v.duration)&&v.duration>0){ v.currentTime=Math.min(time,Math.max(0,v.duration-0.2)); v.addEventListener('seeked',grab,{once:true}); }
      else { v.addEventListener('loadeddata',grab,{once:true}); }
    }, {once:true});
    v.addEventListener('error', ()=>{ URL.revokeObjectURL(url); resolve({poster:'', w:0, h:0}); }, {once:true});
  });
}

function setMediaAspect(holder, w, h){
  if (!holder) return;
  if (w && h) holder.style.setProperty('--ar', `${w}/${h}`);
  else holder.style.removeProperty('--ar');
}
 // includes {collapsed:boolean}
  let mode = 'list';
  let renderCount = 0;
  let pageIndex = parseInt(localStorage.getItem("pageIndex")||"0",10)||0;
let BATCH_SIZE = Math.max(8, Math.min(200, parseInt(localStorage.getItem("pageBatch")||"24",10)||24));
window.pager = {
  enabled: true,
}

  const readAsDataURL = (file)=> new Promise((res, rej)=>{
    const fr = new FileReader(); fr.onerror = rej; fr.onload = ()=> res(fr.result); fr.readAsDataURL(file);
  });

  async function downscale(dataUrl, maxW=1280, maxH=1280, q=.85){
  const img = new Image(); img.decoding='async'; img.src = dataUrl; await img.decode().catch(()=>{});
  const srcW = img.naturalWidth || img.width || 0;
  const srcH = img.naturalHeight || img.height || 0;
  const r = Math.min(1, maxW/srcW, maxH/srcH);
  const cw = Math.round(srcW*r), ch = Math.round(srcH*r);
  const c = document.createElement('canvas'); c.width=cw; c.height=ch;
  const ctx = c.getContext('2d'); ctx.imageSmoothingQuality='high'; ctx.drawImage(img,0,0,cw,ch);
  return { out: c.toDataURL('image/jpeg', q), w: srcW, h: srcH };
};
 
function guessFormatFromFilename(name){
    const m = String(name).match(/\.([a-z0-9]+)$/i); if(!m) return 'IMG';
    const ext = m[1].toUpperCase(); return ext==='JPG' ? 'JPEG' : ext;
  }
  function inferFormat(file){
  if(file && file.type){
    const [,ext] = file.type.split('/');
    return ext ? ext.toUpperCase() : guessFormatFromFilename(file.name);
  }
  return guessFormatFromFilename(file?.name||'');
}

  function inferTimecode(name){
    const base = name.replace(/\.[^.]+$/,'');
    const m = base.match(/(?:^|[_\- ])(\d{1,2})[._-](\d{2})[._-](\d{2})(?:[._-](\d{2}))?/);
    if(!m) return ''; const hh=m[1].padStart(2,'0'), mm=m[2], ss=m[3], ff=m[4]||'00';
    return `${hh}:${mm}:${ss}:${ff}`;
  }
  function tcToFrames(tc, fps){
    if(!tc) return null;
    const m = tc.match(/^(\d{1,2}):(\d{2}):(\d{2})(?::(\d{2}))?$/); if(!m) return null;
    const hh=+m[1], mm=+m[2], ss=+m[3], ff=+(m[4]||0);
    return Math.round(((hh*3600+mm*60+ss)*fps)+ff);
  }
  function framesToTC(frames, fps){
    frames = Math.max(0, Math.round(frames));
    const totalSec = Math.floor(frames / fps), ff = frames % fps;
    const hh = Math.floor(totalSec/3600), mm=Math.floor((totalSec%3600)/60), ss=totalSec%60;
    return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}:${String(ff).padStart(2,'0')}`;
  }
  

// Detect if a WebP is animated by reading RIFF chunks (VP8X flag or ANIM chunk)
async function isAnimatedWebP(file){
  try{
    const buf = await file.arrayBuffer();
    const u8 = new Uint8Array(buf);
    const len = u8.length;
    const tagAt = (i)=> String.fromCharCode(u8[i],u8[i+1],u8[i+2],u8[i+3]||0);
    const u32LE = (i)=> (u8[i] | (u8[i+1]<<8) | (u8[i+2]<<16) | (u8[i+3]<<24)>>>0);
    if(len < 16) return false;
    if(tagAt(0) !== 'RIFF' || tagAt(8) !== 'WEBP') return false;
    let off = 12;
    while(off + 8 <= len){
      const tag = tagAt(off);
      const size = u32LE(off+4) >>> 0;
      const dataOff = off + 8;
      if(tag === 'VP8X' && dataOff + 1 < len){
        const flags = u8[dataOff];
        if((flags & 0x02) !== 0) return true; // animation flag
      }
      if(tag === 'ANIM') return true;
      off = dataOff + size + (size & 1); // chunks padded to even size
    }
    return false;
  }catch{
    return false;
  }
}


  async function videoPoster(file, time=0.1){
    return new Promise((resolve)=>{
      const url = URL.createObjectURL(file), v = document.createElement('video');
      v.preload='metadata'; v.muted=true; v.playsInline=true; v.src=url;
      v.addEventListener('loadedmetadata', ()=>{
        const c=document.createElement('canvas'); c.width=v.videoWidth; c.height=v.videoHeight; const ctx=c.getContext('2d');
        const grab = ()=>{ try{ ctx.drawImage(v,0,0,c.width,c.height); resolve(c.toDataURL('image/jpeg',.85)); }catch{ resolve(''); } URL.revokeObjectURL(url); };
        if(isFinite(v.duration)&&v.duration>0){ v.currentTime=Math.min(time,Math.max(0,v.duration-0.2)); v.addEventListener('seeked',grab,{once:true}); }
        else { v.addEventListener('loadeddata',grab,{once:true}); }
      }, {once:true});
      v.addEventListener('error', ()=>{ URL.revokeObjectURL(url); resolve(''); }, {once:true});
    });
  }

  function setPageModeButtonsState(){ const on = mode==='page'; collapseAllCardsBtn.disabled=!on; expandAllCardsBtn.disabled=!on; }
  modeListBtn.addEventListener('click', ()=>{ mode='list'; modeListBtn.classList.add('active'); modePageBtn.classList.remove('active'); listSection.classList.remove('hidden'); pageSection.classList.add('hidden'); if (window.pager&&window.pager.show) window.pager.show(false); setPageModeButtonsState(); render(); });
  modePageBtn.addEventListener('click', ()=>{ mode='page'; modePageBtn.classList.add('active'); modeListBtn.classList.remove('active'); listSection.classList.add('hidden'); pageSection.classList.remove('hidden'); if (window.pager&&window.pager.show) window.pager.show(true); setPageModeButtonsState(); render(); });
  starFilter.addEventListener('change', ()=>{ resetInfinite(); render(); });
  setPageModeButtonsState();

  collapseAllCardsBtn.addEventListener('click', ()=>{ shots.forEach(s=>s.collapsed=true); render(); });
  expandAllCardsBtn.addEventListener('click', ()=>{ shots.forEach(s=>s.collapsed=false); render(); });

  function filteredShots(){ return starFilter.checked ? shots.filter(s=>s.starred) : shots; }

  function render(){ mode==='list' ? renderList() : renderPage(); }

  function renderList(){
    tbody.innerHTML='';
    filteredShots().forEach((s,i)=>{
      const tr = rowTpl.content.firstElementChild.cloneNode(true); tr.dataset.id=s.id;
      tr.querySelector('.idx').textContent=String(i+1).padStart(3,'0');
      const thumbImg = tr.querySelector('img.thumb');
      thumbImg.src = s.thumb || '';
      if (s.imageURL){
        thumbImg.addEventListener('mouseenter', ()=>{ thumbImg.src = s.imageURL; });
        thumbImg.addEventListener('mouseleave', ()=>{ thumbImg.src = s.thumb || ''; });
        thumbImg.title = 'Hover to preview';
      }
      tr.querySelector('[data-filename]').textContent=s.filename;
      tr.querySelector('.selbox').checked=!!s.selected;
      tr.querySelector('.title').value=s.title||''; tr.querySelector('.starttc').value=s.startTC||''; tr.querySelector('.endtc').value=s.endTC||'';
      tr.querySelector('.desc').value=s.desc||''; tr.querySelector('.camera').value=s.camera||''; tr.querySelector('.lens').value=s.lens||'';
      tr.querySelector('.take').value=s.take||''; tr.querySelector('.notes').value=s.notes||'';
      tr.querySelector('.kind').textContent=s.format||guessFormatFromFilename(s.filename);
      const starEl=tr.querySelector('.starlist'); starEl.textContent=s.starred?'★':'☆'; starEl.style.cursor='pointer';
      starEl.addEventListener('click',()=>{ s.starred=!s.starred; render(); });

      tr.setAttribute('draggable','false');
const handle = tr.querySelector('td.drag .handle');
if (handle) handle.setAttribute('draggable','true');
if (handle) handle.addEventListener('dragstart',(e)=>{
  e.stopPropagation();
  tr.classList.add('dragging');
  e.dataTransfer.setData('text/plain', s.id);
  e.dataTransfer.effectAllowed = 'move';
  const box = window.ensureDropBox ? window.ensureDropBox() : null;
  if (box) box.style.display = 'block';
});
if (handle) handle.addEventListener('dragend',(e)=>{
  e.stopPropagation();
  tr.classList.remove('dragging');
  const box = window.ensureDropBox ? window.ensureDropBox() : null;
  if (box) box.style.display = 'none';
});
tr.addEventListener('dragover',(e)=>{
  e.preventDefault();
  tr.classList.add('ghost');
  const box = window.ensureDropBox ? window.ensureDropBox() : null;
  if (box){
    const r = tr.getBoundingClientRect();
    box.style.left = (window.scrollX + r.left) + 'px';
    box.style.top  = (window.scrollY + r.top) + 'px';
    box.style.width  = r.width + 'px';
    box.style.height = r.height + 'px';
    box.style.display = 'block';
  }
});
tr.addEventListener('dragleave',()=>{
  tr.classList.remove('ghost');
  const box = window.ensureDropBox ? window.ensureDropBox() : null;
  if (box) box.style.display = 'none';
});
tr.addEventListener('drop',(e)=>{
  e.preventDefault();
  tr.classList.remove('ghost');
  const box = window.ensureDropBox ? window.ensureDropBox() : null;
  if (box) box.style.display = 'none';
  reorderById(e.dataTransfer.getData('text/plain'), s.id);
});
tr.querySelector('.selbox').addEventListener('change',e=> s.selected=e.target.checked);
      tr.querySelector('.title').addEventListener('input',e=> s.title=e.target.value);
      tr.querySelector('.starttc').addEventListener('input',e=> s.startTC=e.target.value);
      tr.querySelector('.endtc').addEventListener('input',e=> s.endTC=e.target.value);
      tr.querySelector('.desc').addEventListener('input',e=> s.desc=e.target.value);
      tr.querySelector('.camera').addEventListener('input',e=> s.camera=e.target.value);
      tr.querySelector('.lens').addEventListener('input',e=> s.lens=e.target.value);
      tr.querySelector('.take').addEventListener('input',e=> s.take=e.target.value);
      tr.querySelector('.notes').addEventListener('input',e=> s.notes=e.target.value);

      tr.querySelector('.del').addEventListener('click',()=> removeShot(s.id));
      tbody.appendChild(tr);
    });
  }

  function resetInfinite(){ renderCount = Math.min(BATCH_SIZE, filteredShots().length); }
  window.addEventListener('scroll',()=>{
    if (mode!=='page' || (window.pager && window.pager.enabled)) return;
    const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 800);
    if(nearBottom){ renderCount = Math.min(filteredShots().length, renderCount + BATCH_SIZE); renderPage(); }
  });

  
function renderPage(){
  const list = filteredShots();
  pageContainer.innerHTML='';
  const per = Math.max(1, (typeof BATCH_SIZE!=='undefined' ? (BATCH_SIZE|0) : 24));
  const pages = Math.max(1, Math.ceil(list.length/per));
  if (typeof pageIndex==='undefined') window.pageIndex = 0;
  if (pageIndex >= pages) pageIndex = pages-1;
  if (pageIndex < 0) pageIndex = 0;
  const start = pageIndex*per; const end = Math.min(list.length, start+per);
  if (window.pager && window.pager.show) window.pager.show(true);
  (window.pager && window.pager.update && window.pager.update());
  list.slice(start, end).forEach((s,i)=>{
    const card = cardTpl.content.firstElementChild.cloneNode(true); card.dataset.id=s.id;
    card.querySelector('.idxbadge').textContent = `#${String(start + i + 1).padStart(3,'0')}`;
    const starEl=card.querySelector('.star'); starEl.classList.toggle('on',!!s.starred); starEl.textContent=s.starred?'★':'☆';
    starEl.addEventListener('click',()=>{ s.starred=!s.starred; render(); });

    const titleInput=card.querySelector('.title-input'); titleInput.value=s.title||''; titleInput.addEventListener('input',e=> s.title=e.target.value);

    const img=card.querySelector('.media-img'); const vid=card.querySelector('.media-vid');
    const replaceBtn=card.querySelector('.replace'); const replaceInput=card.querySelector('.replaceInput');
    const holder = img.parentElement;
    setMediaAspect(holder, s.w||0, s.h||0);

    if(s.mediaType==='video' && s.previewURL){
      img.classList.add('hidden');
      const canvas = holder.querySelector('canvas.webpCanvas'); if(canvas) canvas.classList.add('hidden');
      const ctrls = holder.querySelector('.webp-controls'); if(ctrls) ctrls.classList.add('hidden');

      const placeholderVid = vid;
      let cached = window._videoEls.get(s.id);
      if (!cached){
        cached = placeholderVid;
        cached.preload='metadata'; cached.playsInline=true;
        window._videoEls.set(s.id, cached);
      } else if (cached !== placeholderVid){
        placeholderVid.replaceWith(cached);
      }
      cached.classList.remove('hidden');
      if (!cached.dataset.boundMeta){
        cached.addEventListener('loadedmetadata', ()=>{
          if ((!s.w || !s.h) && cached.videoWidth && cached.videoHeight){
            s.w = cached.videoWidth; s.h = cached.videoHeight; setMediaAspect(holder, s.w, s.h);
          }
        }, {once:true});
        cached.dataset.boundMeta='1';
      }
      if (!cached.poster) cached.poster = s.thumb || '';
      if (!cached.src || cached.src !== s.previewURL){ cached.src = s.previewURL; }
    } else {
      let canvas = holder.querySelector('canvas.webpCanvas');
      let ctrls = holder.querySelector('.webp-controls');
      if(!canvas){ canvas = document.createElement('canvas'); canvas.className='webpCanvas hidden'; img.after(canvas); }
      if(!ctrls){
        ctrls = document.createElement('div'); ctrls.className='webp-controls hidden';
        ctrls.innerHTML = `
          <label style="display:flex;align-items:center;gap:.5rem;">
            <span>Frame</span>
            <input type="range" min="0" max="0" value="0" step="1" data-act="slider">
            <span data-act="label">0/0</span>
          </label>`;
        canvas.after(ctrls);
      }
      const slider = ctrls.querySelector('[data-act=slider]');
      const label  = ctrls.querySelector('[data-act=label]');
      const getPlayer = ()=> (window._webpPlayers && window._webpPlayers.get(s.id)) || null;
      const updateUIFromIndex = (idx)=>{
        const p = getPlayer();
        const total = p && p.frames ? p.frames.length : 0;
        label.textContent = total ? `${idx+1}/${total}` : `${idx+1}`;
        if (document.activeElement !== slider) slider.value = String(idx);
        s.webpFrame = idx;
      };
      slider.oninput = () => {
        const p = getPlayer(); if (!p) return;
        const idx = parseInt(slider.value || '0', 10);
        p.seek(idx, updateUIFromIndex);
      };

      if (s.imageURL){
        img.classList.add('hidden'); vid.classList.add('hidden');
        canvas.classList.remove('hidden'); ctrls.classList.remove('hidden');
        canvas.getContext('2d').fillStyle = '#111';
        canvas.width = (s.w||320); canvas.height = (s.h||180);
        canvas.getContext('2d').fillRect(0,0,canvas.width,canvas.height);
        canvas.getContext('2d').fillStyle='#999'; canvas.getContext('2d').fillText('Loading WebP…', 10, 20);
        window._webpPlayers = window._webpPlayers || new Map();
        const ensureLoaded = async ()=>{
          if (typeof WebPPlayer === 'undefined'){
            const startTs = Date.now();
            const poll = ()=>{
              if (typeof WebPPlayer !== 'undefined'){ ensureLoaded(); return; }
              if (Date.now() - startTs > 5000){ console.warn('WebPPlayer not available'); return; }
              setTimeout(poll, 50);
            };
            poll(); return;
          }
          let player = window._webpPlayers.get(s.id);
          if (player && player.url !== s.imageURL){
            try{ player.dispose(); }catch{};
            window._webpPlayers.delete(s.id);
            player = null;
          }
          if(!player){
            player = new WebPPlayer(canvas, s.imageURL);
            window._webpPlayers.set(s.id, player);
            try{ await player.load(); }catch(e){ console.warn('WebP load failed', e); }
          }
          if (player.canvas !== canvas) player.rebindCanvas(canvas);
          const total = player.frames.length;
          s.webpTotalFrames = total || 0;
          slider.max = String(Math.max(0, total-1));
          const startIdx = Number.isInteger(s.webpFrame) ? (s.webpFrame|0) : (player.index|0);
          player.seek(startIdx, updateUIFromIndex);
          if (player.size && player.size.w && player.size.h){
            s.w = s.w || player.size.w;
            s.h = s.h || player.size.h;
            setMediaAspect(holder, s.w, s.h);
          }
        };
        ensureLoaded();
        holder._disposeWebP = ()=>{ try{ const p=(window._webpPlayers&&window._webpPlayers.get(s.id))||null; if(p && p.pause) p.pause(); }catch{}; };
      } else {
        if (holder._disposeWebP){ try{ holder._disposeWebP(); }catch{}; holder._disposeWebP=null; }
        canvas.classList.add('hidden'); ctrls.classList.add('hidden');
        img.classList.remove('hidden'); vid.classList.add('hidden');
        img.onload = ()=>{
          if ((!s.w || !s.h) && img.naturalWidth && img.naturalHeight){ s.w = img.naturalWidth; s.h = img.naturalHeight; setMediaAspect(holder, s.w, s.h); }
        };
        img.src = s.thumb || '';
      }
    }

    replaceBtn.addEventListener('click',()=> replaceInput.click());
    replaceInput.addEventListener('change',async (e)=>{ const f=e.target.files[0]; if(!f) return; await replaceMedia(s,f); render(); });

    const toggleBtn=card.querySelector('.toggleFields');
    if(s.collapsed) card.classList.add('fields-collapsed'); else card.classList.remove('fields-collapsed');
    toggleBtn.addEventListener('click',(e)=>{
      const multi = e.altKey||e.metaKey||e.ctrlKey;
      if(multi){ const ns=!s.collapsed; shots.forEach(x=> x.collapsed=ns); }
      else s.collapsed=!s.collapsed;
      render();
    });

    card.querySelector('.starttc').value=s.startTC||'';
    card.querySelector('.endtc').value=s.endTC||'';
    card.querySelector('.take').value=s.take||'';
    card.querySelector('.camera').value=s.camera||'';
    card.querySelector('.lens').value=s.lens||'';
    card.querySelector('.desc').value=s.desc||'';
    card.querySelector('.filename').textContent=s.filename;
    const kindEl = card.querySelector('.kind');
    kindEl.textContent=s.format||guessFormatFromFilename(s.filename);
    if (s.w && s.h){
      const chip = document.createElement('span');
      const gcd = (a,b)=> b?gcd(b,a%b):a;
      const g = gcd(s.w, s.h) || 1;
      chip.className='chip mini';
      chip.textContent = `${s.w}×${s.h} (${s.w/g}:${s.h/g})`;
      kindEl.after(chip);
    }

    const dragHandle = card.querySelector('.drag-handle');
    card.setAttribute('draggable','false');
    if (dragHandle) dragHandle.setAttribute('draggable','true');
    if (dragHandle) dragHandle.addEventListener('dragstart',(e)=>{
      e.stopPropagation();
      card.classList.add('dragging');
      e.dataTransfer.setData('text/plain', s.id);
      e.dataTransfer.effectAllowed='move';
      const box = ensureDropBox(); box.style.display='block';
    });
    if (dragHandle) dragHandle.addEventListener('dragend',(e)=>{
      e.stopPropagation();
      card.classList.remove('dragging');
      const box = ensureDropBox(); box.style.display='none';
    });
    card.addEventListener('dragstart', (e)=>{ e.preventDefault(); });

    const webpSliderEl = card.querySelector('.webp-controls input[type=range]');
    if (webpSliderEl){
      ['mousedown','pointerdown','touchstart','dragstart'].forEach(ev=>
        webpSliderEl.addEventListener(ev, evObj => evObj.stopPropagation())
      );
    }
    card.addEventListener('dragover',(e)=>{
      e.preventDefault();
      const box = ensureDropBox();
      const r = card.getBoundingClientRect();
      box.style.left = (window.scrollX + r.left) + 'px';
      box.style.top  = (window.scrollY + r.top) + 'px';
      box.style.width  = r.width + 'px';
      box.style.height = r.height + 'px';
      box.style.display = 'block';
    });
    card.addEventListener('dragleave',()=>{
      const box = ensureDropBox(); box.style.display = 'none';
    });
    card.addEventListener('drop',(e)=>{ e.preventDefault(); card.classList.remove('ghost'); reorderById(e.dataTransfer.getData('text/plain'), s.id); });

    card.querySelector('.del').addEventListener('click',()=> removeShot(s.id));

    pageContainer.appendChild(card);
  });
}function reorderById(srcId,destId){
    if(!srcId||srcId===destId) return;
    const from=shots.findIndex(x=>x.id===srcId), to=shots.findIndex(x=>x.id===destId);
    if(from<0||to<0) return; const [moved]=shots.splice(from,1); shots.splice(to,0,moved); render();
  }

  // ingest
  fileInput.addEventListener('change', async (e)=>{ await addFiles(e.target.files); fileInput.value=''; });
  ['dragenter','dragover'].forEach(evt=> dz.addEventListener(evt,(e)=>{ e.preventDefault(); dz.classList.add('hover'); }));
  ['dragleave','drop'].forEach(evt=> dz.addEventListener(evt,(e)=>{ e.preventDefault(); dz.classList.remove('hover'); }));
  dz.addEventListener('drop', async (e)=>{ await addFiles(e.dataTransfer.files); });

  async function addFiles(list){
  for (const f of [...list]){
    if(!f.type || !(f.type.startsWith('image/')||f.type.startsWith('video/'))) continue;
    if(f.type.startsWith('image/')){
      if (f.type === 'image/webp'){
        const [dataUrl, anim] = await Promise.all([readAsDataURL(f), isAnimatedWebP(f)]);
        const d = await downscale(dataUrl,1600,1600,.85);
        const url = URL.createObjectURL(f);
        shots.push({
          id: crypto.randomUUID(),
          filename: f.name,
          format: inferFormat(f),
          mediaType: 'image',
          thumb: d.out,
          imageURL: url,
          isAnimated: !!anim,
          webpFrame: 0, webpTotalFrames: 0,
          w: d.w || 0, h: d.h || 0,
          title: '', startTC: '', endTC: '', desc: '', camera: '', lens: '', take: '', notes: '',
          selected: false, starred: false, collapsed: true
        });
      } else {
        const dataUrl = await readAsDataURL(f);
        const d = await downscale(dataUrl,1600,1600,.85);
        shots.push({
          id: crypto.randomUUID(),
          filename: f.name,
          format: inferFormat(f),
          mediaType: 'image',
          thumb: d.out,
          isAnimated: false,
          webpFrame: 0, webpTotalFrames: 0,
          w: d.w || 0, h: d.h || 0,
          title: '', startTC: '', endTC: '', desc: '', camera: '', lens: '', take: '', notes: '',
          selected: false, starred: false, collapsed: true
        });
      }
    } else {
      const info = await videoPosterInfo(f);
      const url = URL.createObjectURL(f);
      shots.push({
        id: crypto.randomUUID(),
        filename: f.name,
        format: inferFormat(f),
        mediaType: 'video',
        sourceHint: { name: f.name || '', size: (f.size||0), lastModified: (f.lastModified||0), type: f.type || '' },
        previewURL: url,
        thumb: info.poster || '',
        w: info.w || 0, h: info.h || 0,
        webpFrame: 0, webpTotalFrames: 0,
        title: '', startTC: '', endTC: '', desc: '', camera: '', lens: '', take: '', notes: '',
        selected: false, starred: false, collapsed: true
      });
    }
  }
}

async function replaceMedia(shot,file){
  if(!file || !(file.type && (file.type.startsWith('image/')||file.type.startsWith('video/')))) return;
  if(shot.mediaType==='video' && shot.previewURL) try{ URL.revokeObjectURL(shot.previewURL);}catch{}
  if(shot.imageURL) { try{ URL.revokeObjectURL(shot.imageURL); }catch{} }
  shot.filename=file.name; shot.format=inferFormat(file);
  if(file.type.startsWith('image/')){
    if (file.type === 'image/webp'){
      const [dataUrl, anim] = await Promise.all([readAsDataURL(file), isAnimatedWebP(file)]);
      const d = await downscale(dataUrl,1600,1600,.85);
      shot.mediaType='image'; shot.thumb=d.out; delete shot.previewURL;
      shot.isAnimated=!!anim;
      shot.imageURL = URL.createObjectURL(file);
      shot.webpFrame = 0; shot.webpTotalFrames = 0;
      shot.w = d.w||0; shot.h = d.h||0;
    }else{
      const dataUrl=await readAsDataURL(file); const d=await downscale(dataUrl,1600,1600,.85);
      shot.mediaType='image'; shot.thumb=d.out; delete shot.previewURL; shot.isAnimated=false;
      shot.webpFrame = 0; shot.webpTotalFrames = 0; if(shot.imageURL){ try{ URL.revokeObjectURL(shot.imageURL);}catch{} } delete shot.imageURL;
      shot.w = d.w||0; shot.h = d.h||0;
    }
  }else{
    const poster=await videoPoster(file)||''; 
    shot.mediaType='video'; shot.previewURL=URL.createObjectURL(file); shot.thumb=poster; shot.isAnimated=false; shot.webpFrame=0; shot.webpTotalFrames=0;
    shot.sourceHint = { name: file.name || '', size: (file.size||0), lastModified: (file.lastModified||0), type: file.type || '' };
    if(shot.imageURL){ try{ URL.revokeObjectURL(shot.imageURL);}catch{} } delete shot.imageURL;
    shot.w = 0; shot.h = 0; // will be filled on metadata
  }
}

  // selection
  selectAllBtn.addEventListener('click',()=>{ shots.forEach(s=>s.selected=true); render(); });
  deselectAllBtn.addEventListener('click',()=>{ shots.forEach(s=>s.selected=false); render(); });
  deleteSelBtn.addEventListener('click',()=>{ shots.filter(s=>s.selected).map(s=>s.id).forEach(removeShot); });
  relinkVideosBtn.addEventListener('click',()=>{ chooseFolderAndRelink({onlyMissing:false}); });
  clearAllBtn.addEventListener('click',()=>{ if(confirm('Remove all items?')){ shots.forEach(s=>{ if(s.mediaType==='video'&&s.previewURL) try{URL.revokeObjectURL(s.previewURL);}catch{}; if(s.imageURL) try{URL.revokeObjectURL(s.imageURL);}catch{} }); shots=[]; render(); }});

  // batch replace (not append)
  applyBatchBtn.addEventListener('click',()=>{
    const title=batchTitle.value.trim(), take=batchTake.value.trim(), cam=batchCamera.value.trim(), len=batchLens.value.trim(),
          note=batchNotes.value.trim(), desc=batchDesc.value.trim();
    shots.forEach(s=>{ if(!s.selected) return;
      if(title) s.title=title; if(take) s.take=take; if(cam) s.camera=cam; if(len) s.lens=len; if(note) s.notes=note; if(desc) s.desc=desc; });
    render();
  });

  // timecode parse
  parseTCBtn.addEventListener('click',()=>{
    const modeSel=tcMode.value, fps=parseInt(fpsInput.value)||24, defDur=Math.max(1,parseInt(defaultDurInput.value)||2);
    if(modeSel==='fromName'){
      shots.forEach(s=>{ const tc=inferTimecode(s.filename); if(tc){ s.startTC=tc; s.endTC=''; } });
    }else{
      const nameFrames=shots.map(s=> tcToFrames(inferTimecode(s.filename), fps));
      const durations=shots.map((_,i)=>{ const a=nameFrames[i], b=nameFrames[i+1]; return (a!=null && b!=null && b>a) ? (b-a) : defDur*fps; });
      if(durations.length && !durations[durations.length-1]) durations[durations.length-1]=defDur*fps;
      let acc=0; shots.forEach((s,i)=>{ const d=durations[i]||defDur*fps; s.startTC=framesToTC(acc,fps); s.endTC=framesToTC(acc+d,fps); acc+=d; });
    }
    render();
  });

  // export/import
  
exportJSONBtn.addEventListener('click', async ()=>{
  const blobToDataURL = (blob)=> new Promise((res,rej)=>{
    try{ const fr = new FileReader(); fr.onerror = rej; fr.onload = ()=> res(fr.result); fr.readAsDataURL(blob); }
    catch(e){ rej(e); }
  });
  const outShots = [];
  for (const s of shots){
    const { previewURL, imageURL, ...rest } = s;
    const out = { ...rest };
    if (s.mediaType === 'video' && s.sourceHint){ out.sourceHint = s.sourceHint; }
    // Embed animated WebP bytes so import can restore playback
    if (s.mediaType === 'image' && (s.isAnimated || (String(s.format).toUpperCase()==='WEBP' && ((s.webpTotalFrames|0)>1 || (s.webpFrame|0)>0))) && imageURL){
      try{
        const resp = await fetch(imageURL);
        const blob = await resp.blob();
        out.imageData = await blobToDataURL(blob);
      }catch(e){ console.warn('Failed to embed WebP data for export', e); }
    }
    outShots.push(out);
  }
  const data = { meta:{app:'shotlist-maker', v:6, exported:new Date().toISOString()}, shots: outShots };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='shotlist.json'; a.click();
  setTimeout(()=> URL.revokeObjectURL(a.href), 0);
});
  
importJSONInput.addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  const dataURLtoBlob = (dataURL)=>{
    try{
      const [meta, b64] = dataURL.split(',');
      const mime = (meta.match(/^data:([^;]+);base64$/)||[])[1] || 'application/octet-stream';
      const bin = atob(b64); const len = bin.length;
      const u8 = new Uint8Array(len); for(let i=0;i<len;i++) u8[i] = bin.charCodeAt(i);
      return new Blob([u8], {type: mime});
    }catch(e){ console.warn('dataURLtoBlob failed', e); return null; }
  };
  try{
    const data=JSON.parse(await f.text());
    if(Array.isArray(data.shots)){
      shots = data.shots.map((s)=>{
        const base = {
          sourceHint: s.sourceHint || { name: s.filename || '', size: s.size || 0, lastModified: s.lastModified || 0, type: s.type || '' },
          selected:false, starred:!!s.starred, collapsed:true,
          startTC: s.startTC || s.timecode || '',
          format: s.format || (typeof guessFormatFromFilename==='function' && s.filename ? guessFormatFromFilename(s.filename) : s.format),
          mediaType: s.mediaType || 'image',
          ...s
        };
        base.id = base.id || (typeof crypto!=='undefined' && crypto.randomUUID ? crypto.randomUUID() : ('id_'+Math.random().toString(36).slice(2)));
// Restore animated WebP from embedded data
        if (base.mediaType === 'image' && base.imageData){
          const blob = dataURLtoBlob(base.imageData);
          if (blob){
            try{ base.imageURL = URL.createObjectURL(blob); base.isAnimated = true; if(!base.format) base.format='WEBP'; }catch{}
          }
        }
        base.isAnimated = !!base.isAnimated;
        base.webpFrame = Number.isInteger(base.webpFrame) ? base.webpFrame : 0;
        base.webpTotalFrames = Number.isInteger(base.webpTotalFrames) ? base.webpTotalFrames : 0;
        return base;
      });
      if (typeof resetInfinite === 'function') resetInfinite();
      if (typeof render === 'function') render();
      await maybeAutoRelinkVideos();
    } else {
      alert('JSON missing "shots" array.');
    }
  }catch(err){
    console.error(err);
    alert('Failed to import JSON.');
  }
  importJSONInput.value='';
});

  window.loadBoardData = function(data){
    try{
      if (data && data.meta && data.meta.app === 'shotlist-maker' && Array.isArray(data.shots)){
        window.shots = data.shots.map(s => {
          const base = {
          sourceHint: s.sourceHint || { name: s.filename || '', size: s.size || 0, lastModified: s.lastModified || 0, type: s.type || '' },
            selected:false, starred:!!s.starred, collapsed:true,
            startTC: s.startTC || s.timecode || '',
            format: s.format || (typeof guessFormatFromFilename==='function' && s.filename ? guessFormatFromFilename(s.filename) : s.format),
            mediaType: s.mediaType || 'image',
            imageURL: s.imageURL || '',
            previewURL: s.previewURL || '',
            isAnimated: !!s.isAnimated,
            webpFrame: Number.isInteger(s.webpFrame) ? s.webpFrame : 0,
            webpTotalFrames: Number.isInteger(s.webpTotalFrames) ? s.webpTotalFrames : 0,
            ...s
          };
          if (base.mediaType==='image' && base.imageData && !base.imageURL){
            const b = dataURLtoBlob(base.imageData);
            if (b){ try{ base.imageURL = URL.createObjectURL(b); base.isAnimated = true; if(!base.format) base.format='WEBP'; }catch{} }
          }
          return base;
        });
if (typeof window.resetInfinite === 'function') window.resetInfinite();
        if (typeof window.render === 'function') window.render();
      } else { if (typeof applyShotTemplate === 'function') applyShotTemplate(data || {}); else console.warn('No template handler.'); }
    }catch(e){
      console.warn('loadBoardData failed:', e);
      alert('Failed to load template: ' + (e && e.message ? e.message : e));
    }
  };

async function gatherFilesFromDirHandle(dirHandle){
  const files = [];
  async function walk(handle){
    try{
      for await (const [name, h] of handle.entries()){
        if (h.kind === 'file'){
          try{
            const f = await h.getFile();
            if ((f.type||'').startsWith('video/')) files.push(f);
          }catch{}
        }else if (h.kind === 'directory'){
          await walk(h);
        }
      }
    }catch(e){ /* not supported or denied */ }
  }
  await walk(dirHandle);
  return files;
}

function buildSigKey(sig){
  if(!sig) return '';
  const name = (sig.name||'').toLowerCase();
  const size = sig.size||0;
  const lm   = sig.lastModified||0;
  const type = (sig.type||'').toLowerCase();
  return [name, size, lm, type].join('|');
}

async function relinkFromFileList(files, onlyMissing){
  const byStrong = new Map();
  const byName   = new Map();
  for (const f of files){
    const key = buildSigKey({name:f.name,size:f.size,lastModified:f.lastModified,type:f.type});
    byStrong.set(key, f);
    byName.set((f.name||'').toLowerCase(), f);
  }
  let relinked = 0;
  for (const s of shots){
    if (s.mediaType !== 'video') continue;
    if (onlyMissing && s.previewURL) continue;
    const sig = s.sourceHint || {name:s.filename||''};
    const strong = buildSigKey(sig);
    let file = byStrong.get(strong);
    if (!file){
      file = byName.get((sig.name||s.filename||'').toLowerCase());
    }
    if (file){
      try{
        const url = URL.createObjectURL(file);
        s.previewURL = url;
        s.filename = file.name || s.filename;
        s.format = inferFormat(file);
        if (!s.thumb){
          try{ s.thumb = await videoPoster(file) || ''; }catch{}
        }
        s.sourceHint = { name:file.name||'', size:(file.size||0), lastModified:(file.lastModified||0), type:file.type||'' };
        relinked++;
      }catch(e){ console.warn('Failed to relink', e); }
    }
  }
  if (relinked){
    render();
    alert('Relinked ' + relinked + ' video(s).');
  }else{
    alert('No matching videos found in the selected folder.');
  }
}

function countMissingVideos(){
  return shots.filter(s => s.mediaType==='video' && !s.previewURL).length;
}

async function maybeAutoRelinkVideos(){
  const missing = countMissingVideos();
  if (!missing) return;
  const go = confirm('This board has ' + missing + ' video(s) that need re-linking. Pick a folder to scan now?');
  if (go){ await chooseFolderAndRelink({onlyMissing:true}); }
}

async function chooseFolderAndRelink(options){
  options = options || {};
  const onlyMissing = options.onlyMissing !== false; // default true
  let files = [];

  if (window.showDirectoryPicker){
    try{
      const dirHandle = await window.showDirectoryPicker({mode:'read'});
      files = await gatherFilesFromDirHandle(dirHandle);
    }catch(e){ /* user cancelled */ }
  }
  if (!files.length){
    const input = document.createElement('input');
    input.type = 'file';
    input.multiple = true;
    input.accept = 'video/*';
    input.webkitdirectory = true;
    input.directory = true;
    const picked = await new Promise(res => { input.onchange = ()=> res([...input.files]); input.click(); });
    files = picked || [];
  }
  if (!files.length) return;
  await relinkFromFileList(files, onlyMissing);
}



// --- Memory Tools ---
function memUpdateStats(){
  try{
    const total = shots.length;
    let imgURLs = 0, vidURLs = 0;
    for(const s of shots){
      if (s.imageURL) imgURLs++;
      if (s.previewURL) vidURLs++;
    }
    const vcache = (window._videoEls && window._videoEls.size) || 0;
    const wcache = (window._webpPlayers && window._webpPlayers.size) || 0;
    const el = document.getElementById('memStats');
    if (el) el.textContent = `${total} items · ${imgURLs} img URLs · ${vidURLs} vid URLs · ${vcache} video nodes · ${wcache} webp players`;
  }catch{}
}
function memFreeCache(){
  // Pause & drop cached video elements
  if (window._videoEls){
    for (const [id, v] of window._videoEls){
      try{ v.pause(); v.removeAttribute('src'); v.load?.(); }catch{}
    }
    window._videoEls.clear();
  }
  // Dispose WebP players
  if (window._webpPlayers){
    for (const [id, p] of window._webpPlayers){
      try{ p.dispose?.(); }catch{}
    }
    window._webpPlayers.clear();
  }
  memUpdateStats();
  alert('Freed cached video elements and WebP decoders.');
}
function memReleaseURLs(keepN){
  keepN = Math.max(0, parseInt(keepN)||0);
  const list = (typeof filteredShots==='function' ? filteredShots() : shots).slice(0, keepN);
  const keep = new Set(list.map(s=> s.id));
  let img=0, vid=0;
  for (const s of shots){
    if (!keep.has(s.id)){
      if (s.previewURL){ try{ URL.revokeObjectURL(s.previewURL); }catch{}; s.previewURL=''; vid++; }
      if (s.imageURL){ try{ URL.revokeObjectURL(s.imageURL); }catch{}; s.imageURL=''; img++; }
    }
  }
  memFreeCache(); // also drop caches bound to released URLs
  memUpdateStats();
  alert(`Released ${img} image URLs and ${vid} video URLs (kept first ${keepN}).`);
}
function memStripOriginals(keepN){
  keepN = Math.max(0, parseInt(keepN)||0);
  const list = (typeof filteredShots==='function' ? filteredShots() : shots).slice(0, keepN);
  const keep = new Set(list.map(s=> s.id));
  let img=0, vid=0;
  for (const s of shots){
    if (!keep.has(s.id)){
      if (s.mediaType==='image' && s.imageURL){ try{ URL.revokeObjectURL(s.imageURL); }catch{}; delete s.imageURL; img++; }
      if (s.mediaType==='video'){
        if (s.previewURL){ try{ URL.revokeObjectURL(s.previewURL); }catch{}; s.previewURL=''; vid++; }
      }
    }
  }
  memFreeCache();
  memUpdateStats();
  render();
  alert(`Stripped originals for images and videos beyond first ${keepN}.`);
}
(function(){
  const keepNInput = document.getElementById('memKeepN');
  const purgeBtn = document.getElementById('memPurgeCache');
  const relBtn = document.getElementById('memReleaseURLs');
  const stripBtn = document.getElementById('memStripOriginals');
  const pageBatchInput = document.getElementById('pageBatchSize');
  const pageBatchBtn = document.getElementById('applyPageBatch');
  if (pageBatchInput){ pageBatchInput.value = String(Math.max(8, Math.min(200, parseInt(localStorage.getItem('pageBatch')||'24',10)||24))); }
  function valKeep(){ return keepNInput ? parseInt(keepNInput.value||'0',10) : 0; }
  if (purgeBtn) purgeBtn.addEventListener('click', ()=> memFreeCache());
  if (relBtn) relBtn.addEventListener('click', ()=> memReleaseURLs(valKeep()));
  if (stripBtn) stripBtn.addEventListener('click', ()=>{ if(confirm('This will remove original media URLs beyond the kept items. Continue?')) memStripOriginals(valKeep()); });
  if (pageBatchBtn) pageBatchBtn.addEventListener('click', ()=>{
    const v = Math.max(8, Math.min(200, parseInt(pageBatchInput.value||'24',10)||24));
    localStorage.setItem('pageBatch', String(v));
    if (typeof BATCH_SIZE !== 'undefined'){ BATCH_SIZE = v; }
    if (typeof resetInfinite === 'function') resetInfinite();
    if (typeof render === 'function') render();
  });
  // Update stats initially and after major actions
  document.addEventListener('DOMContentLoaded', memUpdateStats);
  const origRender = window.render;
  window.render = function(){ try{ origRender.apply(this, arguments); }catch(e){ (origRender||function(){})(); } memUpdateStats(); };
})();

</script>


<script>
function isPageMode(){
  try{
    var sec = document.getElementById('pageSection');
    return !!(sec && !sec.classList.contains('hidden'));
  }catch(e){ return false; }
}
</script>

<script>
// Paging helpers (Page Mode only)
(function(){
  if (window.pager && window.pager.__wired) return;
  window.pager = Object.assign(window.pager || {}, {
    enabled: true,
    __wired: true,
    el: null, prev: null, next: null, info: null,
    init(){
      this.el = document.getElementById('floatPager');
      this.prev = document.getElementById('pagePrev');
      this.next = document.getElementById('pageNext');
      this.info = document.getElementById('pageInfo');
      if (this.prev) this.prev.addEventListener('click', ()=> window.pager.go(-1));
      if (this.next) this.next.addEventListener('click', ()=> window.pager.go(+1));
      this.update();
    },
    pages(){
      const list = (typeof filteredShots==='function' ? filteredShots() : (window.shots||[]));
      const total = list.length;
      const per = Math.max(1, (typeof BATCH_SIZE!=='undefined' ? (BATCH_SIZE|0) : 24));
      const pages = Math.max(1, Math.ceil(total/per));
      if (typeof pageIndex === 'undefined') window.pageIndex = 0;
      if (pageIndex >= pages) pageIndex = pages-1;
      if (pageIndex < 0) pageIndex = 0;
      return { total, per, pages };
    },
    update(){
      const { pages } = this.pages();
      try{ localStorage.setItem('pageIndex', String(pageIndex)); }catch{}
      if (this.info) this.info.textContent = `Page ${pages ? (pageIndex+1) : 0} / ${pages}`;
      if (this.prev) this.prev.disabled = (pageIndex<=0);
      if (this.next) this.next.disabled = (pageIndex>=pages-1);
    },
    go(delta){
      const { pages } = this.pages();
      pageIndex = Math.max(0, Math.min(pages-1, pageIndex + (delta|0)));
      try{ localStorage.setItem('pageIndex', String(pageIndex)); }catch{}
      if (typeof render==='function') render();
      window.scrollTo({top:0, behavior:'smooth'});
    },
    show(on){
      const el = this.el || document.getElementById('floatPager');
      if (!el) return;
      el.classList.toggle('hidden', !on);
    }
  });
  document.addEventListener('DOMContentLoaded', ()=> window.pager.init());
  // Keyboard shortcuts for pager (Page Mode only, not while typing)
  document.addEventListener('keydown', (e)=>{
    const tag=(e.target&&e.target.tagName||'').toLowerCase();
    const typing=['input','textarea','select'].includes(tag) || (e.target && e.target.isContentEditable);
    if (typing) return;
    if (typeof isPageMode==="function" ? isPageMode() : (window.mode==="page")){
      if (e.key === 'ArrowLeft'){ e.preventDefault(); window.pager.go(-1); }
      else if (e.key === 'ArrowRight'){ e.preventDefault(); window.pager.go(+1); }
    }
  }, true);
})();
</script>

<script>

// Toolbar chevron toggle (persisted)
(function(){
  const t = document.getElementById('toolbarToggle');
  if(!t) return;
  const KEY = 'shotlist.toolbarCollapsed';
  const apply = (on)=>{
    document.body.classList.toggle('toolbar-collapsed', !!on);
    t.textContent = on ? '▼' : '▲';
    const tt = on ? 'Show Toolbar' : 'Hide Toolbar';
    t.title = tt; t.setAttribute('aria-label', tt);
  };
  apply(localStorage.getItem(KEY)==='1');
  t.addEventListener('click', ()=>{
    const on = !(localStorage.getItem(KEY)==='1');
    localStorage.setItem(KEY, on ? '1' : '0');
    apply(on);
  });
})();

  // print
  printBtn.addEventListener('click',()=>{
    if(shots.length===0){ alert('No shots to print.'); return; }
    const list=filteredShots(), w=window.open('','_blank');
    const styles=`@page{size:A4;margin:14mm} body{font:12px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#111}
      .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px} .card{break-inside:avoid;border:1px solid #d7dae0;border-radius:8px;padding:8px}
      .head{display:flex;justify-content:space-between;align-items:center;font-weight:600;margin-bottom:6px;font-size:11px}
      .thumb{width:100%;height:140px;object-fit:cover;background:#000;border-radius:4px}
      .meta{font-size:10px;color:#333;margin-top:4px} .label{color:#6b7280} h1{font-size:14px;margin:0 0 8px} .note{font-size:10px;color:#555;margin-bottom:10px}
      .desc{white-space:pre-wrap}`;
    const title=document.title, time=new Date().toLocaleString();
    const html=`<!doctype html><html><head><meta charset="utf-8"><title>${title} — Print</title><style>${styles}</style><style id="drop-follow-box-style">
    #drop-follow-box{
      position:absolute;
      border:2px dashed #3b82f6;
      border-radius:12px;
      pointer-events:none;
      z-index:9999;
      background:rgba(59,130,246,0.06);
      display:none;
    }
  </style>
  </head><body>
      <h1>Shot List</h1><div class="note">Generated ${time}. Use your browser’s <b>Save as PDF</b>.</div><div class="grid">${
        list.map((s,i)=>`
          <div class="card">
            <div class="head"><div>#${String(i+1).padStart(3,'0')} ${s.starred?'★':''} — ${escapeHtml(s.title||'')}</div><div>${
              escapeHtml((s.startTC||'')+(s.endTC? ' — '+s.endTC : ''))}</div></div>
            <img class="thumb" src="${s.thumb}" alt="thumb">
            <div class="meta"><span class="label">File:</span> ${escapeHtml(s.filename)} &nbsp; <span class="label">Type:</span> ${escapeHtml(s.format||'')}</div>
            <div class="meta"><span class="label">Camera:</span> ${escapeHtml(s.camera||'')} &nbsp; <span class="label">Shot Size:</span> ${escapeHtml(s.lens||'')}</div>
            <div class="meta"><span class="label">Take:</span> ${escapeHtml(s.take||'')}</div>
            <div class="meta desc"><span class="label">Desc:</span> ${escapeHtml(s.desc||'')}</div>
            <div class="meta"><span class="label">Notes:</span> ${escapeHtml(s.notes||'')}</div>
          </div>`).join('')}</div><script>setTimeout(()=>window.print(),400)<\/script></body></html>`;
    w.document.open(); w.document.write(html); w.document.close();
  });
  
  
  // shortcuts (disabled while typing)
  document.addEventListener('keydown',(e)=>{
    const tag=(e.target&&e.target.tagName||'').toLowerCase();
    const typing=['input','textarea','select'].includes(tag) || (e.target && e.target.isContentEditable);
    if(typing) return;
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='a'){ e.preventDefault(); shots.forEach(s=>s.selected=true); render(); }
    else if(e.key==='Delete'){ const any=shots.some(s=>s.selected); if(any){ shots=shots.filter(s=>!s.selected); render(); } }
    else if(e.key.toLowerCase()==='p'){ e.preventDefault(); printBtn.click(); }
  });
  
  function escapeHtml(str){ return String(str).replace(/[&<>\"']/g,s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[s])); }
  
  // --- Export CSV ---
  function csvEscape(v){
  if (v === undefined || v === null) return '';
  const s = String(v).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  }
  function buildCsvRows(list){
  const headers = [
    'Index','Filename','Format','MediaType','Title','Description',
    'Camera','Shot Size','Take','Notes','StartTC','EndTC','Starred','WebPFrame','WebPTotalFrames'
  ];
  const rows = list.map((s, i) => [
    i+1,
    s.filename||'',
    s.format||'',
    s.mediaType||'',
    s.title||'',
    s.desc||'',
    s.camera||'',
    s.lens||'',
    s.take||'',
    s.notes||'',
    s.startTC||'',
    s.endTC||'',
    s.starred ? 1 : 0,
    (Number.isInteger(s.webpFrame) ? s.webpFrame : ''),
    (s.webpTotalFrames || '')
  ]);
  return [headers, ...rows];
  }
  exportCSVBtn.addEventListener('click', (e)=>{
  const list = (typeof filteredShots === 'function' ? filteredShots() : shots) || [];
  if(!list.length){ alert('No shots to export.'); return; }
  // Alt/Option-click to export ALL, otherwise export current filtered view
  const out = (e && e.altKey) ? shots : list;
  const rows = buildCsvRows(out);
  const csv = rows.map(r => r.map(csvEscape).join(',')).join('\r\n');
  const blob = new Blob(["\ufeff"+csv], {type: 'text/csv;charset=utf-8;'}); // BOM for Excel
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'shotlist.csv';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  });
  
  async function gatherFilesFromDirHandle(dirHandle){
    const files = [];
    async function walk(handle){
      try{
        for await (const [name, h] of handle.entries()){
          if (h.kind === 'file'){
            try{
              const f = await h.getFile();
              if ((f.type||'').startsWith('video/')) files.push(f);
            }catch{}
          }else if (h.kind === 'directory'){
            await walk(h);
          }
        }
      }catch(e){ /* not supported or denied */ }
    }
    await walk(dirHandle);
    return files;
  }
  
  function buildSigKey(sig){
    if(!sig) return '';
    const name = (sig.name||'').toLowerCase();
    const size = sig.size||0;
    const lm   = sig.lastModified||0;
    const type = (sig.type||'').toLowerCase();
    return [name, size, lm, type].join('|');
  }
  
  async function relinkFromFileList(files, onlyMissing){
    const byStrong = new Map();
    const byName   = new Map();
    for (const f of files){
      const key = buildSigKey({name:f.name,size:f.size,lastModified:f.lastModified,type:f.type});
      byStrong.set(key, f);
      byName.set((f.name||'').toLowerCase(), f);
    }
    let relinked = 0;
    for (const s of shots){
      if (s.mediaType !== 'video') continue;
      if (onlyMissing && s.previewURL) continue;
      const sig = s.sourceHint || {name:s.filename||''};
      const strong = buildSigKey(sig);
      let file = byStrong.get(strong);
      if (!file){
        file = byName.get((sig.name||s.filename||'').toLowerCase());
      }
      if (file){
        try{
          const url = URL.createObjectURL(file);
          s.previewURL = url;
          s.filename = file.name || s.filename;
          s.format = inferFormat(file);
          if (!s.thumb){
            try{ s.thumb = await videoPoster(file) || ''; }catch{}
          }
          s.sourceHint = { name:file.name||'', size:(file.size||0), lastModified:(file.lastModified||0), type:file.type||'' };
          relinked++;
        }catch(e){ console.warn('Failed to relink', e); }
      }
    }
    if (relinked){
      render();
      alert('Relinked ' + relinked + ' video(s).');
    }else{
      alert('No matching videos found in the selected folder.');
    }
  }
  
  function countMissingVideos(){
    return shots.filter(s => s.mediaType==='video' && !s.previewURL).length;
  }
  
  async function maybeAutoRelinkVideos(){
    const missing = countMissingVideos();
    if (!missing) return;
    const go = confirm('This board has ' + missing + ' video(s) that need re-linking. Pick a folder to scan now?');
    if (go){ await chooseFolderAndRelink({onlyMissing:true}); }
  }
  
  async function chooseFolderAndRelink(options){
    options = options || {};
    const onlyMissing = options.onlyMissing !== false; // default true
    let files = [];
  
    if (window.showDirectoryPicker){
      try{
        const dirHandle = await window.showDirectoryPicker({mode:'read'});
        files = await gatherFilesFromDirHandle(dirHandle);
      }catch(e){ /* user cancelled */ }
    }
    if (!files.length){
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = 'video/*';
      input.webkitdirectory = true;
      input.directory = true;
      const picked = await new Promise(res => { input.onchange = ()=> res([...input.files]); input.click(); });
      files = picked || [];
    }
    if (!files.length) return;
    await relinkFromFileList(files, onlyMissing);
  }
</script>

<script>
// Defensive stubs: if any legacy calls fire, no-op them.
(function(){
  const names = [
    'openTemplates', 'openTemplatesModal', 'showTemplatesModal', 'applyShotTemplate',
    'applyTemplateToSelection', 'applyTemplate', 'replaceFromTemplate', 'replaceTemplate',
    'fetchTemplates', 'loadTemplates', 'loadTemplateCard', 'loadTemplateFromURL',
    'scanTemplatesManifest', 'applyBoardTemplate', 'applyTemplateToBoard'
  ];
  names.forEach(n => { try { if (typeof window[n] === 'function') window[n] = function(){ /* templates disabled */ }; } catch(e){} });
  // Also neutralize any global hotkeys that may open Templates
  window.addEventListener('keydown', function(e){
    if ((e.ctrlKey || e.metaKey) && (e.key === 't' || e.key === 'T')) {
      e.preventDefault();
      e.stopPropagation();
      // templates disabled
    }
  }, true);
})();
</script>

</body>
</html>
